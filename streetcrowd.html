<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MOL Limo ‚Äì t√∂bb l√©p√©ses terv (gyalog + aut√≥)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel:rgba(16,24,40,.78);
      --border:rgba(148,163,184,.22);
      --text:#e5e7eb;
      --muted:#94a3b8;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --blue:#60a5fa;
      --blackbar: rgba(0,0,0,.88);
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #map{height:100%;width:100%;}

    .btn{
      border:1px solid var(--border);
      background:rgba(15,23,42,.72);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:900;
      font-size:14px;
      line-height:1;
      -webkit-tap-highlight-color:transparent;
      user-select:none;
      cursor:pointer;
    }
    .btn:active{transform:translateY(1px);}
    .btn.primary{background:rgba(34,197,94,.18);border-color:rgba(34,197,94,.35);}
    .btn.warn{background:rgba(245,158,11,.18);border-color:rgba(245,158,11,.35);}
    .btn.danger{background:rgba(239,68,68,.18);border-color:rgba(239,68,68,.35);}
    .btn.ghost{background:rgba(15,23,42,.35);}

    .pill{
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:rgba(15,23,42,.45);
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
    }

    /* ===== HUD ===== */
    .hud{
      position:fixed; top:10px; left:10px; right:10px;
      padding:10px;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      backdrop-filter:blur(10px);
      z-index:9999;
    }
    .hudRow{
      width:100%;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .hudRow .pill{ margin-left:auto; }
    .hudMore{
      width:100%;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }

    /* ===== Bottom sheet (planbar) ===== */
    .planbar{
      position:fixed;
      left:10px; right:10px; bottom:10px;
      padding:12px;
      background:var(--blackbar);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      z-index:9999;
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height: 42vh;
      overflow:auto;
    }
    .title{font-weight:1000;letter-spacing:.2px;}
    .small{font-size:13px;color:#d1d5db;}
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      word-break: break-word;
      overflow-wrap:anywhere;
    }
    .hr{border:0;border-top:1px solid rgba(255,255,255,.12);margin:10px 0;}

    .sheetCollapsed{ transform: translateY(calc(100% - 68px)); }
    .sheetHandle{
      height: 22px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
    }
    .sheetHandle::before{
      content:"";
      width: 44px;
      height: 5px;
      border-radius: 99px;
      background: rgba(255,255,255,.28);
      display:block;
    }
    .sheetTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* Popup style */
    .leaflet-popup-content-wrapper,.leaflet-popup-tip{
      background: rgba(10,14,25,.92)!important;
      color: var(--text)!important;
      border:1px solid rgba(255,255,255,.12);
    }
    .leaflet-popup-close-button{color:var(--muted)!important;}
    .popup h3{margin:0 0 6px 0;font-size:16px;}
    .popup .meta{font-size:13px;color:var(--muted);margin-bottom:10px;}
    .popup .row{display:flex;gap:8px;flex-wrap:wrap;}
    .popup .row .btn{padding:9px 10px;font-size:13px;}

    /* Car icon */
    .carIcon{
      width:46px;height:46px;border-radius:16px;
      background:rgba(2,6,23,.78);
      border:1px solid rgba(148,163,184,.25);
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      display:flex;align-items:center;justify-content:center;
      position:relative;
    }
    .carIcon .plate{
      position:absolute; bottom:-18px; left:50%; transform:translateX(-50%);
      background:rgba(2,6,23,.80);
      border:1px solid rgba(148,163,184,.22);
      border-radius:999px;
      padding:2px 7px;
      font-size:11px;
      white-space:nowrap;
    }
    .carIcon.hasGoals{outline:3px solid rgba(239,68,68,.35);}
    .carIcon.selected{outline:3px solid rgba(245,158,11,.78);}
    .carIcon.nearest{ outline:4px solid rgba(34,197,94,.78); animation:pulseG 1.2s infinite; }
    .carIcon.bestPlan{ outline:4px solid rgba(96,165,250,.80); animation:pulseB 1.2s infinite; }
    @keyframes pulseG{
      0%{box-shadow:0 0 0 0 rgba(34,197,94,.28);}
      70%{box-shadow:0 0 0 16px rgba(34,197,94,0);}
      100%{box-shadow:0 0 0 0 rgba(34,197,94,0);}
    }
    @keyframes pulseB{
      0%{box-shadow:0 0 0 0 rgba(96,165,250,.30);}
      70%{box-shadow:0 0 0 16px rgba(96,165,250,0);}
      100%{box-shadow:0 0 0 0 rgba(96,165,250,0);}
    }

    /* Goal icon: plate + number */
    .goalWrap{
      display:flex; flex-direction:column; align-items:center; gap:4px;
      transform: translateY(-2px);
    }
    .goalPlate{
      background: rgba(0,0,0,.82);
      border:1px solid rgba(255,255,255,.18);
      color: #fff;
      padding:3px 7px;
      border-radius:999px;
      font-weight:1000;
      font-size:11px;
      white-space:nowrap;
      box-shadow:0 10px 24px rgba(0,0,0,.20);
    }
    .goalIcon{
      width:34px;height:34px;border-radius:999px;
      background:rgba(239,68,68,.92);
      border:3px solid rgba(255,255,255,.95);
      display:flex;align-items:center;justify-content:center;
      color:#fff;font-weight:1000;
      box-shadow:0 10px 24px rgba(0,0,0,.28);
    }

    /* Short labels on map */
    .routeLabel{
      background:rgba(0,0,0,.82);
      border:1px solid rgba(255,255,255,.14);
      color:#fff;
      padding:6px 10px;
      border-radius:999px;
      font-weight:1000;
      font-size:13px;
      white-space:nowrap;
      box-shadow:0 10px 24px rgba(0,0,0,.25);
    }

    /* Goal mode badge */
    .goalModeBadge{
      position:fixed;
      left:10px; right:10px; top:76px;
      padding:10px 12px;
      background: rgba(239,68,68,.12);
      border:1px solid rgba(239,68,68,.30);
      border-radius:14px;
      backdrop-filter:blur(10px);
      z-index:9999;
      display:none;
      gap:8px;
      align-items:center;
      font-weight:900;
    }
    .goalModeBadge .muted{font-weight:700;color:rgba(229,231,235,.8);}

    /* ===== Drawer (car list) ===== */
    .overlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.45);
      z-index: 10000;
      display:none;
    }
    .drawer{
      position:fixed;
      top:10px; bottom:10px; left:10px;
      width:min(420px, calc(100vw - 20px));
      background: rgba(10,14,25,.96);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      z-index:10001;
      display:none;
      overflow:hidden;
      box-shadow:0 22px 60px rgba(0,0,0,.55);
    }
    .drawerHeader{
      padding:12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drawerHeader .left{
      display:flex; flex-direction:column; gap:4px;
    }
    .drawerHeader .hTitle{ font-weight:1000; }
    .drawerHeader .hSub{ color:var(--muted); font-size:12px; }
    .drawerBody{ padding:12px; display:flex; flex-direction:column; gap:10px; height: calc(100% - 64px); }
    .search{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid rgba(148,163,184,.25);
      background: rgba(15,23,42,.55);
      color: var(--text);
      font-weight:800;
      outline:none;
    }
    .carList{
      flex:1;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding-right:4px;
    }
    .carRow{
      border:1px solid rgba(148,163,184,.18);
      background: rgba(15,23,42,.38);
      border-radius:14px;
      padding:10px;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .carRow .chk{
      width:20px;height:20px; margin-top:2px;
      accent-color: #f59e0b;
    }
    .carRow .main{ flex:1; display:flex; flex-direction:column; gap:4px; }
    .carRow .plate{ font-weight:1000; }
    .carRow .meta{ color:var(--muted); font-size:12px; }
    .carRow .tags{ display:flex; gap:8px; flex-wrap:wrap; }
    .tag{
      font-size:12px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.22);
      background: rgba(2,6,23,.35);
      color:#e5e7eb;
    }
    .tag.goals{ border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.12); }
    .tag.hidden{ border-color: rgba(148,163,184,.25); opacity:.8; }
    .carRow .actions{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .carRow .actions .btn{ padding:9px 10px; font-size:12px; border-radius:12px; }

    /* ===== Mobile UX ===== */
    @media (max-width: 520px){
      .hud{ padding:10px; border-radius:16px; }
      .hudMore{ display:none; }
      .hudMore.open{ display:flex; }

      .hudRow .btn{
        flex: 1 1 32%;
        padding:12px 10px;
        font-size:14px;
      }
      .hudRow .pill{
        width:100%;
        margin-left:0;
        text-align:center;
      }

      .planbar{
        bottom: calc(10px + env(safe-area-inset-bottom));
        max-height: 70vh;
        padding: 10px;
        border-radius: 18px;
      }
      .sheetTop .title{ font-size:16px; }
      .sheetTop .btn{ padding:10px 10px; font-size:13px; }

      .drawer{
        left:10px; right:10px;
        width:auto;
      }
    }
  </style>
</head>

<body>
<div id="map"></div>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="hudRow">
    <button class="btn" id="btnRefresh">Friss√≠t√©s</button>
    <button class="btn ghost" id="btnZones">Z√≥n√°k: KI</button>
    <button class="btn primary" id="btnPlan">Tervez√©s</button>
    <button class="btn" id="btnMe">√ân</button>
    <button class="btn ghost" id="btnMore">T√∂bb‚Ä¶</button>
    <span class="pill" id="pillStatus">‚Äî</span>
  </div>

  <div class="hudMore" id="hudMore">
    <button class="btn" id="btnCarList">Aut√≥lista</button>
    <button class="btn warn" id="btnNearest">Hozz√°m legk√∂zelebbi</button>
    <button class="btn" id="btnShowAll">√ñsszes aut√≥</button>
    <button class="btn danger" id="btnUnhideAll">Rejtettek vissza</button>
    <button class="btn danger" id="btnClearAllGoals">C√©lpontok t√∂rl√©se</button>
  </div>
</div>

<div class="goalModeBadge" id="goalModeBadge">
  <span id="goalModeText">C√©lpont m√≥d</span>
  <span class="muted">‚Äì koppints a t√©rk√©pre (v√°lt√°s: m√°sik aut√≥ra katt)</span>
</div>

<!-- Drawer -->
<div class="overlay" id="overlay"></div>
<div class="drawer" id="drawer">
  <div class="drawerHeader">
    <div class="left">
      <div class="hTitle">Aut√≥k</div>
      <div class="hSub" id="drawerSub">‚Äî</div>
    </div>
    <button class="btn ghost" id="btnDrawerClose">Bez√°r</button>
  </div>
  <div class="drawerBody">
    <input class="search" id="carSearch" placeholder="Keres√©s (rendsz√°m / t√≠pus)‚Ä¶" />
    <div class="carList" id="carList"></div>
  </div>
</div>

<!-- Bottom sheet -->
<div class="planbar sheetCollapsed" id="planbar">
  <div class="sheetHandle" id="sheetHandle"></div>
  <div class="sheetTop">
    <div class="title" id="planTitle">K√©szen √°ll</div>
    <button class="btn ghost" id="btnSheetToggle">‚ñ≤</button>
  </div>
  <div class="small" id="planSub">Aut√≥ra katt ‚Üí c√©lpont m√≥d, majd Tervez√©s.</div>
  <div id="planDetails" class="small"></div>
</div>

<script>
(() => {
  /********************
   * CONFIG
   ********************/
  const URL_CARS  = "https://mollimo.hu/data/cars.js?u7XOvp6hNn";
  const URL_ZONES = "https://mollimo.hu/data/homezones.js?UtaHbFc6QF";
  const CITY_ID_BUDAPEST = "8ee26110-d8e9-4e0d-b4b7-e76fd4e00459";

  const REFRESH_MS = 20000;
  const GOAL_ZONE_RADIUS_M = 350; // 300‚Äì400m k√∂z√©p
  const NEAREST_CANDIDATES = 18;
  const MAX_PLAN_CARS = 10;
  const MAX_GOALS_PER_CAR = 12;

  const WALK_ENGINES = [
    { base: "https://routing.openstreetmap.de/routed-foot", profile: "foot" },
    { base: "https://router.project-osrm.org", profile: "foot" }
  ];
  const DRIVE_ENGINES = [
    { base: "https://router.project-osrm.org", profile: "driving" }
  ];

  const ELEV_APIS = [
    (locStr) => `https://api.opentopodata.org/v1/srtm90m?locations=${encodeURIComponent(locStr)}`,
    (locStr) => `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(locStr)}`
  ];

  const LS_KEY = "mol_limo_planner_v8";

  /********************
   * STATE
   ********************/
  const S = {
    me: null, meMarker: null, meAcc: null,

    cars: new Map(),
    lastSeenMiss: new Map(),

    hiddenCars: new Set(),
    selectedCars: new Set(),  // ‚úÖ aut√≥lista pip√°k
    carGoals: new Map(),
    globalGoalCounter: 0,

    zonesOn: false,
    zoneLayers: [],

    goalModeCarId: null,

    cluster: null,
    carMarkers: new Map(),

    goalMarkers: new Map(),

    layerWalk: L.layerGroup(),
    layerDrive: L.layerGroup(),
    layerLabels: L.layerGroup(),
    layerNearest: L.layerGroup(),

    focusMode: "none",
    focusCarIds: new Set(),
    usedGoalIds: new Set(),

    plan: null,
  };

  /********************
   * MAP
   ********************/
  const map = L.map("map", { zoomControl:false, preferCanvas:true }).setView([47.4979, 19.0402], 12);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom:19 }).addTo(map);
  L.control.zoom({ position:"bottomright" }).addTo(map);

  S.cluster = L.markerClusterGroup({ showCoverageOnHover:false, maxClusterRadius:55, spiderfyOnMaxZoom:true });
  map.addLayer(S.cluster);

  S.layerWalk.addTo(map);
  S.layerDrive.addTo(map);
  S.layerLabels.addTo(map);
  S.layerNearest.addTo(map);

  /********************
   * UI refs
   ********************/
  const $ = (id) => document.getElementById(id);
  const planTitle = $("planTitle");
  const planSub = $("planSub");
  const planDetails = $("planDetails");
  const pillStatus = $("pillStatus");
  const goalModeBadge = $("goalModeBadge");
  const goalModeText = $("goalModeText");
  const planbarEl = $("planbar");
  const hudMoreEl = $("hudMore");

  const overlayEl = $("overlay");
  const drawerEl = $("drawer");
  const drawerSubEl = $("drawerSub");
  const carSearchEl = $("carSearch");
  const carListEl = $("carList");

  function setStatus(t){ pillStatus.textContent = t; }

  function fmtMin(sec){
    if(sec == null || !isFinite(sec)) return "‚Äî";
    const m = Math.max(1, Math.round(sec/60));
    return m + " perc";
  }
  function fmtKm(m){
    if(m == null || !isFinite(m)) return "‚Äî";
    return (m/1000).toFixed(2) + " km";
  }
  function fmtM(x){
    if(x == null || !isFinite(x)) return "‚Äî";
    return Math.round(x) + " m";
  }

  /********************
   * Bottom sheet controls
   ********************/
  let sheetOpen = false;
  function setSheet(open){
    sheetOpen = open;
    if(open){
      planbarEl.classList.remove("sheetCollapsed");
      $("btnSheetToggle").textContent = "‚ñº";
    }else{
      planbarEl.classList.add("sheetCollapsed");
      $("btnSheetToggle").textContent = "‚ñ≤";
    }
  }
  $("sheetHandle").addEventListener("click", ()=> setSheet(!sheetOpen));
  $("btnSheetToggle").addEventListener("click", ()=> setSheet(!sheetOpen));

  function setPlan(t, s){
    planTitle.textContent = t;
    planSub.textContent = s;
    if(String(t).toLowerCase().includes("k√©sz")) setSheet(true);
  }

  /********************
   * Drawer controls
   ********************/
  function openDrawer(){
    overlayEl.style.display = "block";
    drawerEl.style.display = "block";
    renderCarList();
    setTimeout(()=>carSearchEl.focus(), 0);
  }
  function closeDrawer(){
    overlayEl.style.display = "none";
    drawerEl.style.display = "none";
  }
  overlayEl.addEventListener("click", closeDrawer);
  $("btnDrawerClose").addEventListener("click", closeDrawer);

  /********************
   * localStorage
   ********************/
  function save(){
    const obj = {
      hiddenCars: Array.from(S.hiddenCars),
      selectedCars: Array.from(S.selectedCars),
      carGoals: Array.from(S.carGoals.entries()),
      globalGoalCounter: S.globalGoalCounter,
      zonesOn: S.zonesOn,
      focusMode: S.focusMode,
      focusCarIds: Array.from(S.focusCarIds),
      usedGoalIds: Array.from(S.usedGoalIds),
    };
    localStorage.setItem(LS_KEY, JSON.stringify(obj));
  }
  function load(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      S.hiddenCars = new Set(obj.hiddenCars || []);
      S.selectedCars = new Set(obj.selectedCars || []);
      S.carGoals = new Map(obj.carGoals || []);
      S.globalGoalCounter = obj.globalGoalCounter || 0;
      S.zonesOn = !!obj.zonesOn;
      S.focusMode = obj.focusMode || "none";
      S.focusCarIds = new Set(obj.focusCarIds || []);
      S.usedGoalIds = new Set(obj.usedGoalIds || []);
    }catch{}
  }

  /********************
   * JSONP loader
   ********************/
  function loadScript(url, timeout=12000){
    return new Promise((resolve,reject)=>{
      const s = document.createElement("script");
      s.async = true;
      const u = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();
      s.src = u;

      let done = false;
      const to = setTimeout(()=>{
        if(done) return;
        done = true;
        s.remove();
        reject(new Error("Timeout: " + url));
      }, timeout);

      s.onload = ()=>{ if(done) return; done=true; clearTimeout(to); s.remove(); resolve(); };
      s.onerror = ()=>{ if(done) return; done=true; clearTimeout(to); s.remove(); reject(new Error("Load error: " + url)); };

      document.head.appendChild(s);
    });
  }

  /********************
   * Focus mode
   ********************/
  function setFocusNone(){
    S.focusMode = "none";
    S.focusCarIds = new Set();
    S.usedGoalIds = new Set();
    save();
    refreshAllCarIcons();
    renderGoals();
  }
  function setFocusPlan(carIds){
    S.focusMode = "plan";
    S.focusCarIds = new Set(carIds);
    save();
    refreshAllCarIcons();
    renderGoals();
  }

  /********************
   * GPS
   ********************/
  function drawMe(){
    if(!S.me) return;
    const ll = [S.me.lat, S.me.lon];

    if(!S.meMarker){
      S.meMarker = L.circleMarker(ll, { radius: 8, weight: 3, color:"#fff", fillColor:"#60a5fa", fillOpacity: 0.9 }).addTo(map);
      S.meMarker.bindTooltip("√ân");
    } else {
      S.meMarker.setLatLng(ll);
    }

    if(S.meAcc){
      S.meAcc.setLatLng(ll);
      S.meAcc.setRadius(S.me.acc || 30);
    } else {
      S.meAcc = L.circle(ll, { radius: S.me.acc || 30, color:"#60a5fa", weight:1, fillOpacity:0.05 }).addTo(map);
    }
  }

  function startGPS(){
    if(!navigator.geolocation){
      setStatus("GPS: nincs");
      return;
    }
    navigator.geolocation.watchPosition((pos)=>{
      S.me = { lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy || 30, ts: Date.now() };
      drawMe();
    }, ()=>{
      setStatus("GPS: tiltva");
    }, { enableHighAccuracy:true, maximumAge:5000, timeout:12000 });
  }

  /********************
   * Cars normalize
   ********************/
  function carIdFromObj(c){
    const plate = (c?.description?.plate || c?.description?.name || "").trim();
    return plate || (c?.description?.id || ("car_" + Math.random().toString(16).slice(2)));
  }

  function normalizeCar(c){
    const id = carIdFromObj(c);
    const plate = (c?.description?.plate || c?.description?.name || id).trim();
    const model = (c?.description?.model || "").trim();
    const energy = c?.status?.energyLevel ?? null;
    const lat = c?.location?.position?.lat;
    const lon = c?.location?.position?.lon;
    const cityId = c?.description?.cityId ?? c?.cityId ?? null;
    if(typeof lat !== "number" || typeof lon !== "number") return null;
    if(cityId && cityId !== CITY_ID_BUDAPEST) return null;
    return { id, plate, model, energy, lat, lon, cityId };
  }

  function carHasGoals(carId){
    const g = S.carGoals.get(carId);
    return Array.isArray(g) && g.length > 0;
  }

  function makeCarIcon(car){
    const hasGoals = carHasGoals(car.id);
    const selected = S.selectedCars.has(car.id);
    const html = `
      <div class="carIcon ${hasGoals ? "hasGoals" : ""} ${selected ? "selected" : ""}">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M3 13l1-5c.2-1 1-2 2-2h12c1 0 1.8 1 2 2l1 5" stroke="white" stroke-width="1.6" stroke-linecap="round"/>
          <path d="M5 13v5m14-5v5" stroke="white" stroke-width="1.6" stroke-linecap="round"/>
          <path d="M7 18h10" stroke="white" stroke-width="1.6" stroke-linecap="round"/>
          <circle cx="7.5" cy="13.5" r="1.2" fill="white"/><circle cx="16.5" cy="13.5" r="1.2" fill="white"/>
        </svg>
        <div class="plate">${car.plate}</div>
      </div>
    `;
    return L.divIcon({ className:"", html, iconSize:[46,46], iconAnchor:[23,23] });
  }

  function shouldShowCar(carId){
    if(S.hiddenCars.has(carId)) return false;
    if(S.focusMode === "plan") return S.focusCarIds.has(carId);
    return true;
  }

  function removeCarMarker(carId){
    const m = S.carMarkers.get(carId);
    if(m){
      S.cluster.removeLayer(m);
      S.carMarkers.delete(carId);
    }
  }

  function applyCarMarker(carId){
    const car = S.cars.get(carId);
    if(!car) return;

    if(!shouldShowCar(carId)){
      removeCarMarker(carId);
      return;
    }

    let m = S.carMarkers.get(carId);
    if(!m){
      m = L.marker([car.lat, car.lon], { icon: makeCarIcon(car), riseOnHover:true });
      S.carMarkers.set(carId, m);
      S.cluster.addLayer(m);
    }else{
      m.setLatLng([car.lat, car.lon]);
      m.setIcon(makeCarIcon(car));
    }

    m.off("click");
    m.on("click", ()=>{
      if(S.goalModeCarId && S.goalModeCarId !== carId){
        setGoalMode(carId);
      }
      openCarPopup(carId, true);
    });
  }

  function refreshAllCarIcons(){
    for(const carId of S.cars.keys()){
      applyCarMarker(carId);
    }
    renderCarList(); // ‚úÖ lista friss√ºl
  }

  /********************
   * Clear/draw helpers
   ********************/
  function clearLayerGroup(g){ try{ g.clearLayers(); }catch{} }

  function clearRoutesAll(){
    clearLayerGroup(S.layerWalk);
    clearLayerGroup(S.layerDrive);
    clearLayerGroup(S.layerLabels);
    clearLayerGroup(S.layerNearest);
    S.plan = null;
    planDetails.innerHTML = "";

    for(const [, m] of S.carMarkers.entries()){
      const el = m.getElement()?.querySelector(".carIcon");
      if(el){ el.classList.remove("nearest"); el.classList.remove("bestPlan"); }
    }
  }

  function addShortLabel(latlng, text){
    return L.marker(latlng, {
      icon: L.divIcon({ className:"", html:`<div class="routeLabel">${text}</div>`, iconSize:[1,1], iconAnchor:[0,0] }),
      interactive:false
    }).addTo(S.layerLabels);
  }

  function drawRoute(layer, geo, opts){
    const latlngs = geo.coordinates.map(([lon,lat])=>[lat,lon]);
    const poly = L.polyline(latlngs, { ...opts, interactive:false }).addTo(layer);
    return { poly, latlngs };
  }

  function midPoint(latlngs){
    if(!latlngs || latlngs.length === 0) return null;
    return latlngs[Math.floor(latlngs.length/2)];
  }

  /********************
   * Routing helpers
   ********************/
  async function fetchJson(url){
    const r = await fetch(url);
    if(!r.ok) throw new Error("HTTP " + r.status);
    return r.json();
  }

  function walkLooksWrong(distance, duration){
    if(!isFinite(distance) || !isFinite(duration) || duration <= 0) return true;
    const speed = distance / duration;
    return speed > 3.0;
  }

  async function routeAny(engines, a, b, isWalk){
    let lastErr = null;
    for(const e of engines){
      try{
        const url = `${e.base}/route/v1/${e.profile}/${a.lon},${a.lat};${b.lon},${b.lat}?overview=full&geometries=geojson&steps=false`;
        const j = await fetchJson(url);
        const rt = j.routes?.[0];
        if(!rt) throw new Error("no route");
        if(isWalk && walkLooksWrong(rt.distance, rt.duration)) throw new Error("walk sanity failed");
        return { distance: rt.distance, duration: rt.duration, geometry: rt.geometry };
      }catch(err){
        lastErr = err;
      }
    }
    throw lastErr || new Error("route failed");
  }

  async function tableAny(engines, coords, sourcesIdx, destIdx, isWalk){
    let lastErr = null;
    const coordStr = coords.map(p=>`${p.lon},${p.lat}`).join(";");
    const src = sourcesIdx.join(";");
    const dst = destIdx.join(";");
    for(const e of engines){
      try{
        const url = `${e.base}/table/v1/${e.profile}/${coordStr}?annotations=duration,distance&sources=${encodeURIComponent(src)}&destinations=${encodeURIComponent(dst)}`;
        const j = await fetchJson(url);
        if(!j?.durations) throw new Error("no durations");

        if(isWalk){
          const durRow = j.durations?.[0];
          const distRow = j.distances?.[0];
          if(durRow && distRow){
            let bad = 0, cnt = 0;
            for(let i=0;i<durRow.length;i++){
              if(durRow[i] == null || distRow[i] == null) continue;
              cnt++;
              if(walkLooksWrong(distRow[i], durRow[i])) bad++;
            }
            if(cnt > 0 && bad / cnt > 0.4) throw new Error("walk table sanity failed");
          }
        }
        return j;
      }catch(err){
        lastErr = err;
      }
    }
    throw lastErr || new Error("table failed");
  }

  /********************
   * Elevation
   ********************/
  function downsampleLatLngs(latlngs, maxPoints=60){
    if(latlngs.length <= maxPoints) return latlngs;
    const out = [];
    const step = (latlngs.length - 1) / (maxPoints - 1);
    for(let i=0;i<maxPoints;i++){
      const idx = Math.round(i * step);
      out.push(latlngs[idx]);
    }
    return out;
  }

  async function fetchElevationForLatLngs(latlngs){
    const sample = downsampleLatLngs(latlngs, 60);
    const locStr = sample.map(([lat,lon])=>`${lat},${lon}`).join("|");

    for(const makeUrl of ELEV_APIS){
      try{
        const url = makeUrl(locStr);
        const j = await fetchJson(url);
        const res = j?.results;
        if(!Array.isArray(res) || res.length < 2) throw new Error("no elevation");

        const elev = res.map(x => x.elevation).filter(x => typeof x === "number");
        if(elev.length < 2) throw new Error("bad elevation");

        let gain = 0, loss = 0;
        for(let i=1;i<elev.length;i++){
          const d = elev[i] - elev[i-1];
          if(d > 0) gain += d;
          else loss += (-d);
        }
        return { gain, loss };
      }catch(e){}
    }
    return null;
  }

  /********************
   * Goals
   ********************/
  function makeGoalIcon(plate, n){
    return L.divIcon({
      className:"",
      html: `
        <div class="goalWrap">
          <div class="goalPlate">${(plate||"")}</div>
          <div class="goalIcon">${n}</div>
        </div>
      `,
      iconSize:[1,1],
      iconAnchor:[17,30]
    });
  }

  function addGoal(carId, lat, lon){
    if(!S.carGoals.has(carId)) S.carGoals.set(carId, []);
    const arr = S.carGoals.get(carId);

    if(arr.length >= MAX_GOALS_PER_CAR){
      setPlan("T√∫l sok c√©lpont", `Egy aut√≥hoz max ${MAX_GOALS_PER_CAR} c√©lpontot sz√°molok.`);
      return;
    }

    const id = "g_" + (++S.globalGoalCounter) + "_" + Date.now().toString(16);
    arr.push({ id, lat, lon });
    S.selectedCars.add(carId); // ‚úÖ ha c√©lpontozol, automatikusan ‚Äûpipa‚Äù
    save();
    renderGoals();
    refreshAllCarIcons();
    setPlan("C√©lpont hozz√°adva", "Nyomj Tervez√©s-t a sz√°mol√°shoz.");
  }

  function clearGoalsForCar(carId){
    S.carGoals.delete(carId);
    save();
    renderGoals();
    refreshAllCarIcons();
    setPlan("C√©lpontok t√∂r√∂lve", "Nyomj Tervez√©s-t a sz√°mol√°shoz.");
  }

  function clearAllGoals(){
    S.carGoals.clear();
    S.usedGoalIds = new Set();
    save();
    renderGoals();
    refreshAllCarIcons();
    clearRoutesAll();
    setFocusNone();
    setPlan("C√©lpontok t√∂r√∂lve", "Adj c√©lpontot egy aut√≥hoz.");
  }

  function renderGoals(){
    for(const [gid, o] of S.goalMarkers.entries()){
      try{ map.removeLayer(o.marker);}catch{}
      try{ map.removeLayer(o.circle);}catch{}
    }
    S.goalMarkers.clear();

    for(const [carId, goals] of S.carGoals.entries()){
      if(!goals || goals.length === 0) continue;

      if(S.focusMode === "plan" && !S.focusCarIds.has(carId)) continue;

      const plate = S.cars.get(carId)?.plate || carId;

      goals.forEach((g, idx)=>{
        if(S.focusMode === "plan" && S.usedGoalIds.size > 0 && !S.usedGoalIds.has(g.id)) return;

        const n = idx + 1;
        const marker = L.marker([g.lat, g.lon], { icon: makeGoalIcon(plate, n) }).addTo(map);
        const circle = L.circle([g.lat, g.lon], {
          radius: GOAL_ZONE_RADIUS_M,
          color:"#ef4444", weight:2, fillOpacity:0.06, interactive:false
        }).addTo(map);

        marker.on("click", ()=>{
          const html = `
            <div class="popup">
              <h3>${plate} ‚Ä¢ c√©lpont #${n}</h3>
              <div class="row">
                <button class="btn danger" data-act="delGoal">C√©lpont t√∂rl√©se</button>
              </div>
            </div>
          `;
          marker.bindPopup(html, {maxWidth:320}).openPopup();
          setTimeout(()=>{
            const el = marker.getPopup()?.getElement();
            if(!el) return;
            const btn = el.querySelector('button[data-act="delGoal"]');
            if(btn){
              btn.addEventListener("click", ()=>{
                const arr = S.carGoals.get(carId) || [];
                S.carGoals.set(carId, arr.filter(x=>x.id !== g.id));
                if((S.carGoals.get(carId)||[]).length === 0) S.carGoals.delete(carId);
                save();
                renderGoals();
                refreshAllCarIcons();
                try{ marker.closePopup(); }catch{}
              });
            }
          }, 0);
        });

        S.goalMarkers.set(g.id, { marker, circle, carId });
      });
    }
  }

  /********************
   * Goal mode
   ********************/
  function setGoalMode(carId){
    S.goalModeCarId = carId;
    const plate = S.cars.get(carId)?.plate || carId;
    goalModeText.textContent = `C√©lpont m√≥d: ${plate}`;
    goalModeBadge.style.display = "flex";
    S.selectedCars.add(carId); // ‚úÖ pip√°ljuk
    save();
    renderCarList();
    refreshAllCarIcons();
  }
  function clearGoalMode(){
    S.goalModeCarId = null;
    goalModeBadge.style.display = "none";
    save();
  }

  map.on("click", (e)=>{
    if(!S.goalModeCarId) return;

    const t = e.originalEvent?.target;
    if(t && (
      t.closest?.(".hud") ||
      t.closest?.(".planbar") ||
      t.closest?.(".leaflet-popup") ||
      t.closest?.(".leaflet-control") ||
      t.closest?.(".leaflet-marker-icon")
    )) return;

    addGoal(S.goalModeCarId, e.latlng.lat, e.latlng.lng);
  });

  /********************
   * Popup
   ********************/
  function openCarPopup(carId, force=false){
    const car = S.cars.get(carId);
    if(!car) return;

    const hidden = S.hiddenCars.has(carId);
    const goals = S.carGoals.get(carId) || [];

    const html = `
      <div class="popup">
        <h3>${car.plate}</h3>
        <div class="meta">${car.model || "‚Äî"} ‚Ä¢ ${car.energy != null ? Math.round(car.energy/10)+"%" : "‚Äî"} ‚Ä¢ c√©lpontok: ${goals.length}</div>
        <div class="row">
          <button class="btn ${hidden ? "warn" : ""}" data-act="toggleHide">${hidden ? "Megjelen√≠t" : "Elrejt"}</button>
          <button class="btn danger" data-act="goalMode">C√©lpont m√≥d (t√©rk√©pre katt)</button>
          <button class="btn danger" data-act="clearGoals">C√©lpontok t√∂rl√©se</button>
        </div>
        <div class="small">Tervez√©sben automatikusan r√©szt vesz az az aut√≥, amihez van c√©lpont.</div>
      </div>
    `;

    const m = S.carMarkers.get(carId);
    if(!m) return;

    if(force){
      try{ m.closePopup(); }catch{}
    }
    m.bindPopup(html, {maxWidth:360, autoPan:true});
    m.openPopup();

    setTimeout(()=>{
      const el = m.getPopup()?.getElement();
      if(!el) return;

      const bind = (sel, fn)=>{
        const b = el.querySelector(sel);
        if(b) b.addEventListener("click", fn);
      };

      bind('button[data-act="toggleHide"]', ()=>{
        if(S.hiddenCars.has(carId)) S.hiddenCars.delete(carId);
        else S.hiddenCars.add(carId);
        save();
        applyCarMarker(carId);
        renderGoals();
        renderCarList();
        clearRoutesAll();
        try{ m.closePopup(); }catch{}
      });

      bind('button[data-act="goalMode"]', ()=>{
        setGoalMode(carId);
      });

      bind('button[data-act="clearGoals"]', ()=>{
        clearGoalsForCar(carId);
        renderCarList();
        try{ m.closePopup(); }catch{}
      });

    }, 0);
  }

  /********************
   * ZONES
   ********************/
  function clearZones(){
    for(const l of S.zoneLayers) map.removeLayer(l);
    S.zoneLayers = [];
  }

  async function toggleZones(){
    S.zonesOn = !S.zonesOn;
    $("btnZones").textContent = "Z√≥n√°k: " + (S.zonesOn ? "BE" : "KI");
    save();

    if(!S.zonesOn){
      clearZones();
      return;
    }

    setStatus("Z√≥n√°k‚Ä¶");
    try{
      delete window.homezones;
      await loadScript(URL_ZONES);
      const hz = window.homezones;
      if(!Array.isArray(hz)) throw new Error("homezones form√°tum");

      clearZones();
      const items = hz.filter(x => x?.cityId === CITY_ID_BUDAPEST && x?.zone?.type === "FeatureCollection");
      for(const it of items){
        const fc = it.zone;
        for(const f of (fc.features || [])){
          const t = f?.properties?.type;
          const color = (t === "allowed") ? "#22c55e" : "#ef4444";
          const fillOpacity = (t === "allowed") ? 0.08 : 0.12;
          const layer = L.geoJSON(f, { style:{ color, weight:2, fillOpacity, opacity:0.9, interactive:false }});
          layer.addTo(map);
          S.zoneLayers.push(layer);
        }
      }
      setStatus("Z√≥n√°k: OK");
    }catch(e){
      console.error(e);
      setStatus("Z√≥n√°k: HIBA");
      setPlan("Z√≥na hiba", "Nem siker√ºlt bet√∂lteni a homezones.js-t (URL token v√°ltozhat).");
    }
  }

  /********************
   * Cars refresh
   ********************/
  async function refreshCars(){
    setStatus("Friss√≠t√©s‚Ä¶");
    try{
      delete window.cars;
      await loadScript(URL_CARS);
      let arr = window.cars;
      if(!Array.isArray(arr)) arr = arr?.cars || arr?.vehicles || arr?.data || [];
      if(!Array.isArray(arr)) throw new Error("cars.js form√°tum");

      const seen = new Set();
      for(const raw of arr){
        const car = normalizeCar(raw);
        if(!car) continue;
        S.cars.set(car.id, car);
        S.lastSeenMiss.set(car.id, 0);
        seen.add(car.id);
      }

      // ha refreshkor elt≈±nt: c√©lpont t√∂rl√©s + pipa t√∂rl√©s
      for(const carId of Array.from(S.carGoals.keys())){
        if(!seen.has(carId)){
          S.carGoals.delete(carId);
          S.selectedCars.delete(carId);
        }
      }
      for(const carId of Array.from(S.selectedCars)){
        if(!seen.has(carId)){
          S.selectedCars.delete(carId);
        }
      }

      for(const [carId, miss] of Array.from(S.lastSeenMiss.entries())){
        if(seen.has(carId)) continue;
        const m2 = (miss || 0) + 1;
        S.lastSeenMiss.set(carId, m2);
        if(m2 >= 2){
          S.cars.delete(carId);
          S.lastSeenMiss.delete(carId);
          S.hiddenCars.delete(carId);
          removeCarMarker(carId);
        }
      }

      renderGoals();
      refreshAllCarIcons();
      save();

      setStatus(`Aut√≥k: ${S.cars.size}`);
    }catch(e){
      console.error(e);
      setStatus("Friss√≠t√©s: HIBA");
      setPlan("Hiba", "Nem siker√ºlt bet√∂lteni a cars.js-t (URL token v√°ltozhat).");
    }
  }

  /********************
   * Aut√≥lista render + events
   ********************/
  function energyPct(energyLevel){
    if(energyLevel == null || !isFinite(energyLevel)) return "‚Äî";
    return Math.round(energyLevel/10) + "%";
  }

  function renderCarList(){
    if(drawerEl.style.display !== "block") return;

    const q = (carSearchEl.value || "").trim().toLowerCase();
    const all = Array.from(S.cars.values());

    all.sort((a,b)=> (a.plate||"").localeCompare(b.plate||""));

    const rows = [];
    let shown = 0;

    for(const c of all){
      const plate = c.plate || c.id;
      const model = c.model || "";
      const hay = (plate + " " + model).toLowerCase();
      if(q && !hay.includes(q)) continue;

      const hidden = S.hiddenCars.has(c.id);
      const goals = (S.carGoals.get(c.id) || []);
      const hasGoals = goals.length > 0;
      const checked = S.selectedCars.has(c.id) || hasGoals;

      rows.push(`
        <div class="carRow" data-id="${c.id}">
          <input class="chk" type="checkbox" ${checked ? "checked" : ""} data-act="toggleSelect" />
          <div class="main">
            <div class="plate">${plate}</div>
            <div class="meta">${model || "‚Äî"} ‚Ä¢ ${energyPct(c.energy)}</div>
            <div class="tags">
              <span class="tag ${hasGoals ? "goals" : ""}">c√©lpontok: ${goals.length}</span>
              ${hidden ? `<span class="tag hidden">rejtett</span>` : ``}
              ${S.goalModeCarId === c.id ? `<span class="tag">c√©lpont m√≥d</span>` : ``}
            </div>
          </div>
          <div class="actions">
            <button class="btn" data-act="goto">Odaugr√°s</button>
            <button class="btn danger" data-act="goalMode">C√©lpont m√≥d</button>
            <button class="btn ${hidden ? "warn" : ""}" data-act="toggleHide">${hidden ? "Megjelen√≠t" : "Elrejt"}</button>
            <button class="btn danger" data-act="clearGoals">C√©lpontok t√∂rl√©se</button>
          </div>
        </div>
      `);
      shown++;
    }

    drawerSubEl.textContent = `√ñsszes: ${S.cars.size} ‚Ä¢ List√°ban: ${shown} ‚Ä¢ Pip√°lt: ${S.selectedCars.size}`;
    carListEl.innerHTML = rows.join("");
  }

  carSearchEl.addEventListener("input", ()=> renderCarList());

  carListEl.addEventListener("click", (e)=>{
    const row = e.target.closest(".carRow");
    if(!row) return;
    const carId = row.getAttribute("data-id");
    const act = e.target.getAttribute("data-act");

    if(act === "goto"){
      const car = S.cars.get(carId);
      if(car){
        map.setView([car.lat, car.lon], Math.max(map.getZoom(), 15), {animate:true});
        openCarPopup(carId, true);
      }
      return;
    }

    if(act === "goalMode"){
      setGoalMode(carId);
      closeDrawer();
      const car = S.cars.get(carId);
      if(car) map.setView([car.lat, car.lon], Math.max(map.getZoom(), 15), {animate:true});
      return;
    }

    if(act === "toggleHide"){
      if(S.hiddenCars.has(carId)) S.hiddenCars.delete(carId);
      else S.hiddenCars.add(carId);
      save();
      applyCarMarker(carId);
      renderGoals();
      renderCarList();
      clearRoutesAll();
      return;
    }

    if(act === "clearGoals"){
      clearGoalsForCar(carId);
      renderCarList();
      return;
    }
  });

  carListEl.addEventListener("change", (e)=>{
    const row = e.target.closest(".carRow");
    if(!row) return;
    const carId = row.getAttribute("data-id");
    const act = e.target.getAttribute("data-act");
    if(act !== "toggleSelect") return;

    const checked = e.target.checked;
    if(checked) S.selectedCars.add(carId);
    else S.selectedCars.delete(carId);

    save();
    refreshAllCarIcons(); // friss√≠ti a narancs keretet
    renderCarList();
  });

  /********************
   * Nearest-to-me (walk)
   ********************/
  function haversine(aLat,aLon,bLat,bLon){
    const R = 6371000;
    const toRad = (x)=>x*Math.PI/180;
    const dLat = toRad(bLat-aLat);
    const dLon = toRad(bLon-aLon);
    const s1 = Math.sin(dLat/2), s2 = Math.sin(dLon/2);
    const aa = s1*s1 + Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*s2*s2;
    return 2*R*Math.asin(Math.min(1, Math.sqrt(aa)));
  }

  async function computeNearestToMe(draw=true){
    if(!S.me){
      setPlan("GPS", "Enged√©lyezd a GPS-t (HTTPS kell).");
      return;
    }
    const cars = Array.from(S.cars.values()).filter(c=>!S.hiddenCars.has(c.id));
    if(cars.length === 0) return;

    cars.sort((a,b)=>haversine(S.me.lat,S.me.lon,a.lat,a.lon)-haversine(S.me.lat,S.me.lon,b.lat,b.lon));
    const pick = cars.slice(0, Math.min(NEAREST_CANDIDATES, cars.length));

    const start = {lat:S.me.lat, lon:S.me.lon};
    const coords = [start, ...pick.map(c=>({lat:c.lat, lon:c.lon}))];
    const sources = [0];
    const dest = pick.map((_,i)=>i+1);

    let tbl;
    try{
      tbl = await tableAny(WALK_ENGINES, coords, sources, dest, true);
    }catch(e){
      setPlan("Hiba", "Gyalog t√°bla hiba (rate limit).");
      return;
    }

    const durs = tbl?.durations?.[0];
    const dists = tbl?.distances?.[0];
    if(!durs || !durs.length) return;

    let bestI = 0;
    for(let i=1;i<durs.length;i++){
      if(durs[i] != null && durs[i] < durs[bestI]) bestI = i;
    }
    const bestCar = pick[bestI];

    clearLayerGroup(S.layerNearest);
    const rt = await routeAny(WALK_ENGINES, start, {lat:bestCar.lat, lon:bestCar.lon}, true).catch(()=>null);
    if(draw && rt?.geometry){
      const r = drawRoute(S.layerNearest, rt.geometry, { weight: 8, opacity: 0.95, dashArray: "10 10" });
      const mid = midPoint(r.latlngs);
      if(mid) addShortLabel(mid, `üö∂ ${fmtMin(rt.duration)} ‚Ä¢ ${fmtKm(rt.distance)}`);
      map.fitBounds(L.latLngBounds([[start.lat,start.lon],[bestCar.lat,bestCar.lon]]).pad(0.25), { animate:true });
    }

    for(const [, m] of S.carMarkers.entries()){
      const el = m.getElement()?.querySelector(".carIcon");
      if(el) el.classList.remove("nearest");
    }
    const mm = S.carMarkers.get(bestCar.id);
    if(mm){
      setTimeout(()=>mm.getElement()?.querySelector(".carIcon")?.classList.add("nearest"), 0);
    }
    setStatus(`Legk√∂zelebbi: ${bestCar.plate} (${fmtMin(durs[bestI])})`);
  }

  /********************
   * PLAN (DP) ‚Äì ugyanaz, mint eddig
   ********************/
  function getPlanCars(){
    const ids = [];
    for(const [carId, goals] of S.carGoals.entries()){
      if(!goals || goals.length === 0) continue;
      if(S.hiddenCars.has(carId)) continue;
      if(!S.cars.has(carId)) continue;
      ids.push(carId);
    }
    return ids;
  }

  function renderPlanDetails(plan){
    const lines = [];
    lines.push(`<div><b>Legjobb sorrend:</b> <span class="mono">${plan.orderPlates.join(" ‚Üí ")}</span></div>`);
    lines.push(`<div><b>√ñssz-id≈ë:</b> ${fmtMin(plan.totalSec)} (üö∂ ${fmtMin(plan.totalWalkSec)} + üöó ${fmtMin(plan.totalDriveSec)})</div>`);
    lines.push(`<div class="hr"></div>`);

    let step = 1;
    for(const leg of plan.legs){
      const emoji = (leg.type==="walk") ? "üö∂" : "üöó";
      const elevTxt = (leg.type==="walk" && leg.elev) ? ` ‚Ä¢ ‚Üó ${fmtM(leg.elev.gain)} ‚Üò ${fmtM(leg.elev.loss)}` : "";
      lines.push(`<div><b>${step++}.</b> ${emoji} <span class="mono">${leg.from.label}</span> ‚Üí <span class="mono">${leg.to.label}</span> ‚Ä¢ <b>${fmtMin(leg.duration)}</b> ‚Ä¢ ${fmtKm(leg.distance)}${elevTxt}</div>`);
    }
    planDetails.innerHTML = lines.join("");
  }

  async function plan(){
    clearGoalMode();
    clearRoutesAll();

    const carIds = getPlanCars();
    if(carIds.length === 0){
      setPlan("Nincs terv", "Adj c√©lpontot legal√°bb 1 aut√≥hoz.");
      return;
    }
    if(carIds.length > MAX_PLAN_CARS){
      setPlan("T√∫l sok aut√≥", `C√©lpontos aut√≥k: ${carIds.length}. Rejts el p√°rat (max ${MAX_PLAN_CARS}).`);
      return;
    }

    const start = S.me
      ? {lat:S.me.lat, lon:S.me.lon}
      : (()=>{ const c = map.getCenter(); return {lat:c.lat, lon:c.lng}; })();

    const cars = carIds.map(id=>S.cars.get(id));

    const goalsFlat = [];
    for(const carId of carIds){
      const goals = (S.carGoals.get(carId) || []).slice(0, MAX_GOALS_PER_CAR);
      goals.forEach((g, idx)=>goalsFlat.push({carId, goal:g, n: idx+1}));
    }

    const G = goalsFlat.length;
    const C = cars.length;

    const walkCoords = [start, ...goalsFlat.map(x=>({lat:x.goal.lat, lon:x.goal.lon})), ...cars.map(c=>({lat:c.lat, lon:c.lon}))];
    const walkSources = Array.from({length: 1+G}, (_,i)=>i);
    const walkDest    = Array.from({length: C}, (_,i)=> (1+G+i));

    const driveCoords = [...cars.map(c=>({lat:c.lat, lon:c.lon})), ...goalsFlat.map(x=>({lat:x.goal.lat, lon:x.goal.lon}))];
    const driveSources = Array.from({length:C}, (_,i)=>i);
    const driveDest = Array.from({length:G}, (_,i)=> (C+i));

    setPlan("Sz√°mol√°s‚Ä¶", "Gyalog + aut√≥ t√°bl√°k‚Ä¶");

    let walkTbl, driveTbl;
    try{
      [walkTbl, driveTbl] = await Promise.all([
        tableAny(WALK_ENGINES, walkCoords, walkSources, walkDest, true),
        tableAny(DRIVE_ENGINES, driveCoords, driveSources, driveDest, false)
      ]);
    }catch(e){
      setPlan("Hiba", "OSRM table hiba (rate limit/profil).");
      return;
    }

    const walkDur = walkTbl.durations;
    const walkDist = walkTbl.distances;
    const driveDur = driveTbl.durations;
    const driveDist = driveTbl.distances;

    const goalsByCar = new Map();
    for(let gi=0; gi<G; gi++){
      const cid = goalsFlat[gi].carId;
      if(!goalsByCar.has(cid)) goalsByCar.set(cid, []);
      goalsByCar.get(cid).push(gi);
    }

    const FULL = (1<<C)-1;
    const dp = Array.from({length: 1<<C}, ()=> new Map());
    const parent = Array.from({length: 1<<C}, ()=> new Map());

    for(let i=0;i<C;i++){
      const cid = carIds[i];
      const gList = goalsByCar.get(cid) || [];
      const w0 = walkDur[0]?.[i];
      if(!isFinite(w0)) continue;

      for(const gi of gList){
        const d0 = driveDur[i]?.[gi];
        if(!isFinite(d0)) continue;

        const mask = (1<<i);
        const key = `${i}|${gi}`;
        const cost = w0 + d0;
        dp[mask].set(key, cost);
        parent[mask].set(key, { pmask:0, pkey:null, pickedCar:i, pickedGoal:gi });
      }
    }

    for(let mask=1; mask<=FULL; mask++){
      for(const [key, cost] of dp[mask].entries()){
        const lastGoal = parseInt(key.split("|")[1],10);
        const srcIdx = 1 + lastGoal;

        for(let j=0;j<C;j++){
          if(mask & (1<<j)) continue;
          const w = walkDur[srcIdx]?.[j];
          if(!isFinite(w)) continue;

          const cid = carIds[j];
          const gList = goalsByCar.get(cid) || [];
          for(const gj of gList){
            const d = driveDur[j]?.[gj];
            if(!isFinite(d)) continue;

            const nmask = mask | (1<<j);
            const nkey = `${j}|${gj}`;
            const ncost = cost + w + d;

            const cur = dp[nmask].get(nkey);
            if(cur == null || ncost < cur){
              dp[nmask].set(nkey, ncost);
              parent[nmask].set(nkey, { pmask:mask, pkey:key, pickedCar:j, pickedGoal:gj });
            }
          }
        }
      }
    }

    let bestKey = null, bestCost = Infinity;
    for(const [k, v] of dp[FULL].entries()){
      if(v < bestCost){ bestCost=v; bestKey=k; }
    }
    if(!bestKey){
      setPlan("Nincs megold√°s", "Nem siker√ºlt √©rtelmes √∫tvonalat tal√°lni.");
      return;
    }

    const orderRev = [];
    const chosenGoalByCarIdx = new Map();
    let curMask = FULL;
    let curKey = bestKey;
    while(curMask !== 0 && curKey){
      const p = parent[curMask].get(curKey);
      if(!p) break;
      orderRev.push(p.pickedCar);
      chosenGoalByCarIdx.set(p.pickedCar, p.pickedGoal);
      curMask = p.pmask;
      curKey = p.pkey;
    }
    const orderIdx = orderRev.reverse();
    const orderCarIds = orderIdx.map(i=>carIds[i]);
    const orderPlates = orderIdx.map(i=>cars[i].plate);

    S.usedGoalIds = new Set();
    for (const ci of orderIdx) {
      const gi = chosenGoalByCarIdx.get(ci);
      const goalObj = goalsFlat[gi]?.goal;
      if (goalObj?.id) S.usedGoalIds.add(goalObj.id);
    }
    save();

    setFocusPlan(orderCarIds);
    renderGoals();

    const firstMarker = S.carMarkers.get(orderCarIds[0]);
    if(firstMarker){
      setTimeout(()=>firstMarker.getElement()?.querySelector(".carIcon")?.classList.add("bestPlan"), 0);
    }

    let totalWalkSec = 0, totalDriveSec = 0;
    const legs = [];

    { // start->car1 walk
      const c0 = orderIdx[0];
      legs.push({
        type:"walk",
        from:{label:"√ân", point:start},
        to:{label:cars[c0].plate, point:{lat:cars[c0].lat, lon:cars[c0].lon}},
        duration: walkDur[0][c0],
        distance: walkDist?.[0]?.[c0] ?? null,
        elev:null
      });
    }

    for(let k=0;k<orderIdx.length;k++){
      const ci = orderIdx[k];
      const gi = chosenGoalByCarIdx.get(ci);
      const goal = goalsFlat[gi];

      legs.push({
        type:"drive",
        from:{label:cars[ci].plate, point:{lat:cars[ci].lat, lon:cars[ci].lon}},
        to:{label:`${cars[ci].plate} c√©lpont #${goal.n}`, point:{lat:goal.goal.lat, lon:goal.goal.lon}},
        duration: driveDur[ci][gi],
        distance: driveDist?.[ci]?.[gi] ?? null,
        elev:null
      });

      if(k < orderIdx.length-1){
        const cj = orderIdx[k+1];
        legs.push({
          type:"walk",
          from:{label:`${cars[ci].plate} c√©lpont #${goal.n}`, point:{lat:goal.goal.lat, lon:goal.goal.lon}},
          to:{label:cars[cj].plate, point:{lat:cars[cj].lat, lon:cars[cj].lon}},
          duration: walkDur[1+gi][cj],
          distance: walkDist?.[1+gi]?.[cj] ?? null,
          elev:null
        });
      }
    }

    setPlan("√ötvonal rajzol√°s‚Ä¶", "Val√≥s gyalog + aut√≥ √∫tvonalak‚Ä¶");

    const allBoundsPts = [];
    for(const leg of legs){
      const isWalk = (leg.type === "walk");
      const engines = isWalk ? WALK_ENGINES : DRIVE_ENGINES;

      try{
        const rt = await routeAny(engines, leg.from.point, leg.to.point, isWalk);
        leg.duration = rt.duration;
        leg.distance = rt.distance;

        const layer = isWalk ? S.layerWalk : S.layerDrive;
        const style = isWalk ? { weight:7, opacity:.95, dashArray:"10 10" } : { weight:7, opacity:.95 };

        const drawn = drawRoute(layer, rt.geometry, style);
        const mid = midPoint(drawn.latlngs);

        if(mid){
          addShortLabel(mid, `${isWalk ? "üö∂" : "üöó"} ${fmtMin(rt.duration)} ‚Ä¢ ${fmtKm(rt.distance)}`);
        }

        if(isWalk){
          const elev = await fetchElevationForLatLngs(drawn.latlngs);
          leg.elev = elev;
        }

        allBoundsPts.push([leg.from.point.lat, leg.from.point.lon]);
        allBoundsPts.push([leg.to.point.lat, leg.to.point.lon]);

      }catch(e){}

      if(leg.type === "walk") totalWalkSec += (leg.duration||0);
      else totalDriveSec += (leg.duration||0);
    }

    const planObj = { orderCarIds, orderPlates, legs, totalWalkSec, totalDriveSec, totalSec: totalWalkSec + totalDriveSec };
    S.plan = planObj;

    renderPlanDetails(planObj);

    if(allBoundsPts.length){
      map.fitBounds(L.latLngBounds(allBoundsPts).pad(0.25), {animate:true});
    }
    setPlan("K√©sz", "Terv k√©sz. A t√∂bbi aut√≥ elrejtve (√ñsszes aut√≥ gombbal vissza).");
  }

  /********************
   * Buttons
   ********************/
  $("btnRefresh").addEventListener("click", refreshCars);
  $("btnZones").addEventListener("click", toggleZones);
  $("btnPlan").addEventListener("click", plan);
  $("btnNearest").addEventListener("click", ()=> computeNearestToMe(true));
  $("btnShowAll").addEventListener("click", ()=> setFocusNone());
  $("btnUnhideAll").addEventListener("click", ()=>{
    S.hiddenCars.clear();
    save();
    refreshAllCarIcons();
    renderGoals();
  });
  $("btnClearAllGoals").addEventListener("click", ()=>{
    if(confirm("Minden c√©lpont t√∂rl√©se?")) clearAllGoals();
  });
  $("btnMe").addEventListener("click", ()=>{
    if(S.me) map.setView([S.me.lat, S.me.lon], Math.max(map.getZoom(), 14), {animate:true});
  });
  $("btnMore").addEventListener("click", ()=> hudMoreEl.classList.toggle("open"));
  $("btnCarList").addEventListener("click", openDrawer);

  /********************
   * Auto refresh (nem tervez √∫jra)
   ********************/
  setInterval(refreshCars, REFRESH_MS);

  /********************
   * Init
   ********************/
  load();
  $("btnZones").textContent = "Z√≥n√°k: " + (S.zonesOn ? "BE" : "KI");

  startGPS();
  refreshCars();

  if(S.zonesOn){
    S.zonesOn = false;
    $("btnZones").textContent = "Z√≥n√°k: KI";
    toggleZones();
  }

  renderGoals();
  refreshAllCarIcons();
  renderCarList();

})();
</script>
</body>
</html>
