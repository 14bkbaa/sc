<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Carsharing tervező (MOL Limo + Hot zone)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin="anonymous">

  <style>
    :root{
      --bg: rgba(12,18,28,.88);
      --bg2: rgba(12,18,28,.74);
      --text: #f3f7ff;
      --muted: rgba(243,247,255,.68);
      --line: rgba(255,255,255,.10);
      --accent: #ffb000;
      --good: #16a34a;
      --bad: #dc2626;
      --chip: rgba(255,255,255,.10);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --r: 16px;
    }
    html, body { height: 100%; margin: 0; }
    body { background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #map { position: fixed; inset: 0; }

    /* Floating controls */
    .hud{
      position: fixed;
      z-index: 1000;
      left: 10px; top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: min(520px, calc(100vw - 20px));
      pointer-events: none;
    }
    .card{
      pointer-events: auto;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      overflow: hidden;
    }
    .row{ display:flex; gap:8px; align-items:center; }
    .pad{ padding: 10px; }
    .title{ font-weight: 700; font-size: 14px; }
    .sub{ font-size: 12px; color: var(--muted); }
    .btn{
      appearance: none; border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .btn:active{ transform: scale(.99); }
    .btn.primary{ border-color: rgba(22,163,74,.55); background: rgba(22,163,74,.20); }
    .btn.danger{ border-color: rgba(220,38,38,.55); background: rgba(220,38,38,.18); }
    .btn.warn{ border-color: rgba(255,176,0,.55); background: rgba(255,176,0,.18); }
    .btn.ghost{ background: transparent; }
    .btn.small{ padding: 8px 10px; font-size: 12px; }
    .btn.loading { opacity: 0.7; cursor: wait; } /* Loading state */

    .toggle{
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      display:flex; gap:8px; align-items:center;
      cursor: pointer;
      user-select: none;
    }
    .dot{ width:10px; height:10px; border-radius: 999px; background: rgba(255,255,255,.25); }
    .toggle.on .dot{ background: var(--accent); }

    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--line);
      color: var(--text);
      font-weight: 700;
      font-size: 12px;
    }

    /* Status bar (black strip) */
    .statusbar{
      position: fixed; z-index: 1200;
      left: 0; right: 0; bottom: 0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: rgba(0,0,0,.86);
      color: #fff;
      font-size: 13px;
      line-height: 1.35;
      border-top: 1px solid rgba(255,255,255,.12);
      display:none;
    }
    .statusbar.show{ display:block; }
    .statusbar b{ font-size: 14px; }
    .statusbar .muted{ color: rgba(255,255,255,.7); }

    /* Results sheet */
    .sheet{
      position: fixed; z-index: 1100;
      left: 10px; right: 10px;
      bottom: 10px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      max-width: 900px;
      margin: 0 auto;
      border-radius: 18px;
      overflow: hidden;
      display:none;
    }
    .sheet.show{ display:block; }
    .sheetHeader{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding: 12px 12px;
      background: rgba(0,0,0,.55);
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .sheetHeader .title{ font-size: 14px; }
    .sheetBody{
      max-height: min(56vh, 520px);
      overflow: auto;
      padding: 10px 12px;
    }
    .steps{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .step{
      padding: 10px 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      display:flex; gap:10px; align-items:flex-start;
    }
    .badge{
      min-width: 28px; height: 28px;
      border-radius: 999px;
      display:flex; align-items:center; justify-content:center;
      font-weight: 800;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.12);
    }
    .stepTitle{ font-weight: 800; }
    .stepMeta{ font-size: 12px; color: rgba(255,255,255,.72); margin-top: 2px; }
    .kv{
      display:flex; gap:10px; flex-wrap:wrap; margin-top: 6px;
      font-size: 12px; color: rgba(255,255,255,.78);
    }
    .kv span{
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
    }

    /* Car list drawer */
    .drawer{
      position: fixed; z-index: 1300;
      right: 10px; top: 10px;
      width: min(420px, calc(100vw - 20px));
      max-height: min(82vh, 760px);
      display:none;
    }
    .drawer.show{ display:block; }
    .drawerHeader{
      padding: 10px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.30);
    }
    .drawerBody{ max-height: calc(min(82vh, 760px) - 52px); overflow: auto; padding: 10px 10px; }
    .search{
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.28);
      color: var(--text);
      outline: none;
      font-size: 14px;
    }
    .carItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 10px 8px;
      border-bottom: 1px dashed rgba(255,255,255,.12);
    }
    .carLeft{ display:flex; gap:10px; align-items:flex-start; min-width: 0; }
    .chk{
      width: 20px; height: 20px;
      accent-color: var(--accent);
      flex: 0 0 auto;
      margin-top: 1px;
    }
    .carMain{ min-width: 0; }
    .plate{ font-weight: 900; letter-spacing: .5px; }
    .carMeta{ font-size: 12px; color: rgba(255,255,255,.72); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .carBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .carBtns .btn{ padding: 8px 10px; font-size: 12px; }
    .tag{
      display:inline-flex;
      align-items:center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      font-size: 11px;
      color: rgba(255,255,255,.80);
      margin-top: 6px;
      gap:6px;
    }

    /* Leaflet marker labels */
    .plate-label{
      background: rgba(0,0,0,.70);
      color: #fff;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 4px 8px;
      font-weight: 900;
      font-size: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .target-label{
      background: rgba(220,38,38,.92);
      color: #fff;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,.18);
      font-weight: 900;
      font-size: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .target-label small{
      font-weight: 800; opacity: .9;
    }

    /* Mobile: move drawer to full-screen bottom */
    @media (max-width: 720px){
      .hud{ left: 8px; right: 8px; top: 8px; }
      .drawer{
        right: 8px; left: 8px;
        top: auto;
        bottom: 8px;
        bottom: calc(8px + env(safe-area-inset-bottom));
        width: auto;
        max-height: min(60vh, 500px); /* Optimalizált magasság mobilra */
      }
      .drawerBody{ max-height: calc(min(60vh, 500px) - 52px); }
      .sheet{ left: 8px; right: 8px; bottom: 8px; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Floating HUD -->
  <div class="hud">
    <div class="card pad">
      <div class="row" style="justify-content:space-between; align-items:flex-start;">
        <div>
          <div class="title">Carsharing tervező</div>
          <div class="sub" id="subLine">Betöltés…</div>
        </div>
        <div class="row" style="gap:6px;">
          <button class="btn small ghost" id="btnCars" aria-label="Lista megnyitása">Autók</button>
          <button class="btn small" id="btnRefresh" aria-label="Frissítés">Frissítés</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px; flex-wrap:wrap;">
        <button class="btn primary" id="btnPlan" aria-label="Tervezés indítása">Tervezés</button>
        <button class="btn" id="btnMe" aria-label="Saját pozíció">Én</button>
        <div class="toggle" id="toggleZones" title="MOL Limo zónák" role="switch" aria-checked="false">
          <div class="dot"></div><div style="font-weight:800; font-size:13px;">Zónák</div>
        </div>
        <div class="toggle" id="toggleBkv" title="GTFS / BKV (ha be van állítva)" role="switch" aria-checked="false">
          <div class="dot"></div><div style="font-weight:800; font-size:13px;">BKV</div>
        </div>
        <button class="btn danger" id="btnShowAll" aria-label="Minden autó megjelenítése">Összes autó</button>
      </div>

      <div class="row" style="margin-top:10px; flex-wrap:wrap;">
        <span class="pill" id="pillCars">Autók: —</span>
        <span class="pill" id="pillSelected">Kijelölt: 0</span>
        <span class="pill" id="pillTargets">Hot zone: 0</span>
        <span class="pill" id="pillMode">Mód: —</span>
      </div>
    </div>
  </div>

  <!-- Car list drawer -->
  <div class="drawer card" id="drawer">
    <div class="drawerHeader">
      <div>
        <div class="title">Autók</div>
        <div class="sub" id="drawerSub">—</div>
      </div>
      <button class="btn small" id="btnCloseDrawer" aria-label="Lista bezárása">Bezár</button>
    </div>
    <div class="drawerBody">
      <input class="search" id="carSearch" placeholder="Keresés (rendszám / típus)..." aria-label="Autó keresés" />
      <div style="height:10px;"></div>
      <div id="carList"></div>
      <div style="height:10px;"></div>
      <div class="sub">
        Tipp: <b>autóra katt</b> → „Hot zone mód”, utána <b>térképre katt</b> a zóna felvételéhez (300–400 m kör).
      </div>
    </div>
  </div>

  <!-- Plan sheet -->
  <div class="sheet card" id="sheet">
    <div class="sheetHeader">
      <div>
        <div class="title" id="sheetTitle">Kész</div>
        <div class="sub" id="sheetSub">—</div>
      </div>
      <div class="row" style="gap:6px;">
        <button class="btn small" id="btnReplan">Újratervezés</button>
        <button class="btn small danger" id="btnClearPlan">Bezár</button>
      </div>
    </div>
    <div class="sheetBody">
      <div class="steps" id="steps"></div>
    </div>
  </div>

  <!-- Black status strip -->
  <div class="statusbar" id="statusbar">
    <b id="statusTitle">—</b><br>
    <span class="muted" id="statusText">—</span>
  </div>

  <!-- JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin="anonymous"></script>

  <script>
/* GTFS helper (opcionális) */
(() => {
  'use strict';

  const GTFS = {
    _ready: false,
    _stops: null,
    _edges: null,
    _adj: null,

    async init() {
      try {
        const r = await fetch('./gtfs/graph.json', { cache: 'force-cache' });
        if (!r.ok) return false;
        const j = await r.json();
        if (!j || !Array.isArray(j.stops) || !Array.isArray(j.edges)) return false;

        GTFS._stops = j.stops;
        GTFS._edges = j.edges;

        // adjacency
        GTFS._adj = Array.from({ length: GTFS._stops.length }, () => []);
        for (const e of GTFS._edges) {
          if (typeof e.from !== 'number' || typeof e.to !== 'number' || typeof e.w !== 'number') continue;
          GTFS._adj[e.from].push(e);
        }

        GTFS._ready = true;
        return true;
      } catch {
        return false;
      }
    },

    isReady() { return GTFS._ready; },

    // Return nearest stop indices to a point.
    nearestStops(pt, k = 6, maxM = 1200) {
      if (!GTFS._ready) return [];
      const res = [];
      for (let i = 0; i < GTFS._stops.length; i++) {
        const s = GTFS._stops[i];
        const d = haversineM(pt.lat, pt.lng, s.lat, s.lon);
        if (d <= maxM) res.push({ i, d });
      }
      res.sort((a,b)=>a.d-b.d);
      return res.slice(0, k);
    },

    // Plan with a basic Dijkstra between nearby stops (no times).
    // Returns geometry as straight lines between stops (since shapes are not used).
    async plan(from, to, opt = {}) {
      if (!GTFS._ready) return null;

      const maxWalk = opt.maxWalkToStopM ?? 900;
      const startStops = GTFS.nearestStops(from, 6, maxWalk);
      const endStops = GTFS.nearestStops(to, 6, maxWalk);

      if (!startStops.length || !endStops.length) return null;

      // walking speed (m/s) and transfer penalty
      const walkSpeed = 1.25; // ~4.5 km/h
      const walkCost = (m) => m / walkSpeed;

      // Dijkstra from multiple sources
      const N = GTFS._stops.length;
      const dist = new Float64Array(N);
      const prev = new Int32Array(N);
      const prevEdge = new Int32Array(N);
      for (let i=0;i<N;i++){ dist[i]=Infinity; prev[i]=-1; prevEdge[i]=-1; }

      // simple binary heap
      const heap = [];
      const push = (d, i) => { heap.push([d,i]); siftUp(heap.length-1); };
      const pop = () => {
        if (!heap.length) return null;
        const top = heap[0];
        const last = heap.pop();
        if (heap.length) { heap[0]=last; siftDown(0); }
        return top;
      };
      const siftUp = (idx) => {
        while (idx>0){
          const p=(idx-1)>>1;
          if (heap[p][0] <= heap[idx][0]) break;
          [heap[p],heap[idx]]=[heap[idx],heap[p]];
          idx=p;
        }
      };
      const siftDown = (idx) => {
        for(;;){
          const l=idx*2+1, r=l+1;
          let s=idx;
          if (l<heap.length && heap[l][0] < heap[s][0]) s=l;
          if (r<heap.length && heap[r][0] < heap[s][0]) s=r;
          if (s===idx) break;
          [heap[s],heap[idx]]=[heap[idx],heap[s]];
          idx=s;
        }
      };

      for (const ss of startStops) {
        dist[ss.i] = walkCost(ss.d);
        push(dist[ss.i], ss.i);
      }

      const endSet = new Set(endStops.map(x => x.i));
      let bestEnd = null;

      while (heap.length) {
        const [d,u] = pop();
        if (d !== dist[u]) continue;
        if (endSet.has(u)) { bestEnd = u; break; }
        for (let ei=0; ei<GTFS._adj[u].length; ei++){
          const e = GTFS._adj[u][ei];
          const nd = d + e.w;
          if (nd < dist[e.to]) {
            dist[e.to] = nd;
            prev[e.to] = u;
            prevEdge[e.to] = GTFS._edges.indexOf(e);
            push(nd, e.to);
          }
        }
      }

      if (bestEnd == null) return null;

      // add final walking to destination
      const endChoice = endStops.reduce((a,x)=> (x.i===bestEnd && x.d < (a?.d ?? Infinity)) ? x : a, null)
        || endStops[0];
      const total = dist[bestEnd] + walkCost(endChoice.d);

      // Build polyline
      const chain = [];
      let cur = bestEnd;
      chain.push(cur);
      while (prev[cur] !== -1) { cur = prev[cur]; chain.push(cur); }
      chain.reverse();

      const geometry = [];
      geometry.push({ lat: from.lat, lng: from.lng });

      // connect to first stop
      const s0 = GTFS._stops[chain[0]];
      geometry.push({ lat: s0.lat, lng: s0.lon });

      for (let k=1;k<chain.length;k++){
        const s = GTFS._stops[chain[k]];
        geometry.push({ lat: s.lat, lng: s.lon });
      }

      geometry.push({ lat: to.lat, lng: to.lng });

      return {
        totalDuration: total,
        totalDistance: null,
        geometry,
        meta: {
          startStop: s0.name,
          endStop: GTFS._stops[bestEnd].name,
          stops: chain.length
        }
      };
    }
  };

  function haversineM(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = (d) => d*Math.PI/180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }

  window.GTFS = GTFS;
})();

</script>
  <script>
/* Carsharing tervező – index.html-hez
   CORS JAVÍTOTT VERZIÓ + OPTIMALIZÁCIÓK
*/
(() => {
  'use strict';

  // ----------------------- Config -----------------------
  const CFG = {
    // MOL Limo publikus adatfájlok - CORS Proxy-val
    LIMO_CARS_URLS: [
      'https://corsproxy.io/?' + encodeURIComponent('https://mollimo.hu/data/cars.js?u7XOvp6hNn'),
      'https://corsproxy.io/?' + encodeURIComponent('https://mollimo.hu/data/cars.js'),
    ],
    LIMO_ZONES_URLS: [
      'https://corsproxy.io/?' + encodeURIComponent('https://mollimo.hu/data/homezones.js?UtaHbFc6QF'),
      'https://corsproxy.io/?' + encodeURIComponent('https://mollimo.hu/data/homezones.js'),
    ],
    // Budapest CITY_ID
    BUDAPEST_CITY_ID: '8ee26110-d8e9-4e0d-b4b7-e76fd4e00459',

    // OSRM
    OSRM_FOOT: [
      'https://routing.openstreetmap.de/routed-foot',
    ],
    OSRM_CAR: [
      'https://routing.openstreetmap.de/routed-car',
      'https://router.project-osrm.org',
    ],

    // Hot zone sugár (m)
    HOTZONE_RADIUS_M: 360,
    HOTZONE_RADIUS_MIN: 300,
    HOTZONE_RADIUS_MAX: 400,

    // Gyalog: mennyi stop-ig engedjük el (BKV módnál)
    TRANSIT_MAX_WALK_TO_STOP_M: 900,

    // Kijelöléskor szétfeszítés
    SPREAD_DISTANCE_M: 30,
    SPREAD_RING_M: 22,

    // Debounce
    AUTOPLAN_DEBOUNCE_MS: 1200, // Növeltük 700-ról
    REFRESH_COOLDOWN_MS: 1200,

    // Cache limit
    MAX_CACHE_SIZE: 100, // Új beállítás

    // Map defaults
    DEFAULT_CENTER: [47.4979, 19.0402],
    DEFAULT_ZOOM: 12,

    // Storage key
    STORAGE_KEY: 'streetcrowd_planner_v5_cors',
  };

  // ----------------------- Helper Class: LRU Cache -----------------------
  class SimpleLRU {
    constructor(limit) {
      this.limit = limit;
      this.cache = new Map();
    }
    get(key) {
      if (!this.cache.has(key)) return undefined;
      const val = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, val);
      return val;
    }
    set(key, val) {
      if (this.cache.has(key)) this.cache.delete(key);
      else if (this.cache.size >= this.limit) {
        this.cache.delete(this.cache.keys().next().value);
      }
      this.cache.set(key, val);
    }
    has(key) { return this.cache.has(key); }
  }

  // ----------------------- DOM helpers -----------------------
  const $ = (id) => document.getElementById(id);

  function showStatus(title, text, ms = 2400) {
    const bar = $('statusbar');
    $('statusTitle').textContent = title || '—';
    $('statusText').textContent = text || '—';
    bar.classList.add('show');
    if (ms > 0) {
      clearTimeout(showStatus._t);
      showStatus._t = setTimeout(() => bar.classList.remove('show'), ms);
    }
  }

  function setSubline(text) { $('subLine').textContent = text; }

  function debounce(fn, ms) {
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  }

  function fmtKm(m) { return (m/1000).toFixed(m >= 10000 ? 0 : 2) + ' km'; }
  function fmtMin(s) {
    const min = Math.max(0, Math.round(s/60));
    if (min < 60) return `${min} perc`;
    const h = Math.floor(min/60);
    const m = min % 60;
    return `${h} ó ${m} p`;
  }

  // ----------------------- Storage -----------------------
  function loadState() {
    try {
      const raw = localStorage.getItem(CFG.STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }
  function saveState() {
    const st = {
      hidden: Array.from(state.hiddenCars),
      selected: Array.from(state.selectedCars),
      zonesByCar: state.zonesByCar,
      hotRadius: state.hotRadius,
      ui: {
        zonesOn: state.zonesOn,
        bkvOn: state.bkvOn
      }
    };
    localStorage.setItem(CFG.STORAGE_KEY, JSON.stringify(st));
  }

  // ----------------------- Global state -----------------------
  const state = {
    map: null,

    // layers
    tiles: null,
    carsCluster: null,
    carsSelectedLayer: null,
    carsAllMarkers: new Map(),     // carId -> marker
    carsSelectedMarkers: new Map(),// carId -> marker
    zoneLayer: null,
    hotZoneLayer: null,
    routeLayer: null,
    labelLayer: null,

    // data
    cars: [],               // normalized cars
    carsById: new Map(),    // id -> car
    limoZones: null,        // L.GeoJSON or group
    limoZonesLoaded: false,

    // user
    me: null,               // {lat,lng,acc,ts}
    meMarker: null,
    meCircle: null,

    // selections
    activeCarId: null,      // for hotzone add mode
    selectedCars: new Set(),
    hiddenCars: new Set(),
    zonesByCar: {},         // carId -> [{lat,lng,idx,labelId}, ...]
    hotRadius: CFG.HOTZONE_RADIUS_M,

    // mode flags
    zonesOn: false,
    bkvOn: false,
    planActive: false,
    plan: null,

    // refresh throttling
    _lastRefresh: 0,

    // caches (Optimalizált LRU)
    osrmCache: new SimpleLRU(CFG.MAX_CACHE_SIZE),
    elevationCache: new SimpleLRU(CFG.MAX_CACHE_SIZE),
  };

  // ----------------------- Init map -----------------------
  function initMap() {
    const map = L.map('map', {
      zoomControl: true,
      preferCanvas: true
    }).setView(CFG.DEFAULT_CENTER, CFG.DEFAULT_ZOOM);

    state.tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap',
      crossOrigin: true,
    }).addTo(map);

    state.carsCluster = L.markerClusterGroup({
      showCoverageOnHover: false,
      spiderfyOnMaxZoom: true,
      maxClusterRadius: 50,
      disableClusteringAtZoom: 18,
    }).addTo(map);

    state.carsSelectedLayer = L.layerGroup().addTo(map);
    state.zoneLayer = L.layerGroup().addTo(map);
    state.hotZoneLayer = L.layerGroup().addTo(map);
    state.routeLayer = L.layerGroup().addTo(map);
    state.labelLayer = L.layerGroup().addTo(map);

    state.map = map;

    map.on('click', onMapClick);

    // Better touch handling
    map.on('popupopen', () => map.closePopup()); // we don't use popups

    // Try get GPS immediately (auto)
    startGps();

    // UI hooks
    $('btnRefresh').addEventListener('click', () => refreshCars(false));
    $('btnCars').addEventListener('click', () => toggleDrawer(true));
    $('btnCloseDrawer').addEventListener('click', () => toggleDrawer(false));
    $('btnMe').addEventListener('click', centerOnMe);
    $('btnPlan').addEventListener('click', () => planNow(true));
    $('btnReplan').addEventListener('click', () => planNow(true));
    $('btnClearPlan').addEventListener('click', clearPlanView);
    $('btnShowAll').addEventListener('click', showAllCars);

    $('toggleZones').addEventListener('click', () => setZonesOn(!state.zonesOn));
    $('toggleBkv').addEventListener('click', () => setBkvOn(!state.bkvOn));

    // Debounced search
    $('carSearch').addEventListener('input', debounce(renderCarList, 300));

    // Load previous state
    const st = loadState();
    if (st) {
      state.hiddenCars = new Set(st.hidden || []);
      state.selectedCars = new Set(st.selected || []);
      state.zonesByCar = st.zonesByCar || {};
      state.hotRadius = clampNumber(st.hotRadius ?? CFG.HOTZONE_RADIUS_M, CFG.HOTZONE_RADIUS_MIN, CFG.HOTZONE_RADIUS_MAX);
      state.zonesOn = !!(st.ui && st.ui.zonesOn);
      state.bkvOn = !!(st.ui && st.ui.bkvOn);
    }

    setZonesOn(state.zonesOn, true);
    setBkvOn(state.bkvOn, true);

    // initial load
    refreshCars(true);
    loadLimoZones(); // async, but can fail gracefully

    // Javított GTFS inicializálás
    if (window.GTFS && typeof window.GTFS.init === 'function') {
      window.GTFS.init().then((ok) => {
        if (!ok) {
           if(state.bkvOn) {
               showStatus('BKV: KI', 'GTFS graph.json hiányzik', 3000);
               setBkvOn(false);
           }
        }
      }).catch(() => {});
    }
    
    // Globális hibakezelés
    window.addEventListener('unhandledrejection', (event) => {
        console.warn('Unhandled promise rejection:', event.reason);
    });
  }

  function clampNumber(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // ----------------------- GPS -----------------------
  let gpsWatchId = null;
  function startGps() {
    if (!navigator.geolocation) {
      showStatus('GPS', 'A böngésző nem támogatja a geolokációt.');
      return;
    }
    if (gpsWatchId != null) return;

    gpsWatchId = navigator.geolocation.watchPosition(
      (pos) => {
        const { latitude, longitude, accuracy } = pos.coords;
        state.me = { lat: latitude, lng: longitude, acc: accuracy, ts: Date.now() };
        renderMe();
        updatePills();
      },
      (err) => {
        showStatus('GPS hiba', err.message || String(err));
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 12000 }
    );
  }

  function renderMe() {
    if (!state.me) return;
    const ll = [state.me.lat, state.me.lng];
    if (!state.meMarker) {
      const icon = L.divIcon({
        className: '',
        html: `<div style="
          width:18px;height:18px;border-radius:999px;
          background:#4ade80;
          border:3px solid rgba(0,0,0,.55);
          box-shadow:0 10px 30px rgba(0,0,0,.35);
        "></div>`,
        iconSize: [18,18],
        iconAnchor: [9,9],
      });
      state.meMarker = L.marker(ll, { icon, interactive: false }).addTo(state.labelLayer);
      state.meCircle = L.circle(ll, {
        radius: Math.max(10, Math.min(200, state.me.acc || 30)),
        color: 'rgba(74,222,128,.65)',
        fillColor: 'rgba(74,222,128,.20)',
        fillOpacity: 0.25,
        weight: 2,
        interactive: false
      }).addTo(state.labelLayer);
    } else {
      state.meMarker.setLatLng(ll);
      state.meCircle.setLatLng(ll);
      state.meCircle.setRadius(Math.max(10, Math.min(200, state.me.acc || 30)));
    }
  }

  function centerOnMe() {
    if (!state.me) {
      showStatus('GPS', 'Még nincs pozíció (engedélyezd a helyzetet).', 3000);
      return;
    }
    state.map.setView([state.me.lat, state.me.lng], Math.max(state.map.getZoom(), 15), { animate: true });
  }

  // ----------------------- Limo data loading -----------------------
  
  // Javított adatlekérő a CORS proxy-hoz
  async function fetchTextAny(urls) {
    let lastErr = null;
    for (const u of urls) {
      try {
        // Cache buster csak ha nincs benne query
        const urlToFetch = u.includes('corsproxy.io') ? u : (u + (u.includes('?') ? '&' : '?') + 't=' + Date.now());
        const r = await fetch(urlToFetch);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.text();
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error('fetch failed');
  }

  // Javított parser: biztonságosabb array kinyerés
  function extractAndParseJsArray(text) {
     const match = text.match(/=\s*(\[.*\]|\{.*\})\s*;?\s*$/s);
     if (match && match[1]) {
       try {
         return new Function('"use strict"; return (' + match[1] + ')')();
       } catch(e) { console.error('Parse error', e); return null; }
     }
     return null;
  }

  function carIdFromObj(o){
    return String(
      o?.description?.id ||
      o?.description?.plate ||
      o?.description?.name ||
      o?.id ||
      o?.plate ||
      o?.licensePlate ||
      o?.license_plate ||
      o?.car_id ||
      o?.code ||
      (o?.name ? o.name : '')
    ) || ('car_' + Math.random().toString(16).slice(2));
  }

  function normalizeCar(raw) {
    // MOL Limo formátum kezelés
    const lat = raw?.location?.position?.lat ?? raw?.lat ?? raw?.latitude ?? raw?.Latitude ?? raw?.LAT ?? raw?.y;
    const lng = raw?.location?.position?.lon ?? raw?.location?.position?.lng ?? raw?.lon ?? raw?.lng ?? raw?.longitude ?? raw?.Longitude ?? raw?.LNG ?? raw?.x;
    if (lat == null || lng == null) return null;

    const id = carIdFromObj(raw);
    const plate = String(raw?.description?.plate ?? raw?.description?.name ?? raw?.plate ?? raw?.licensePlate ?? raw?.license_plate ?? raw?.reg ?? id).toUpperCase().trim();
    const model = raw?.description?.model ?? raw?.model ?? raw?.type ?? raw?.carType ?? raw?.brand ?? raw?.vehicleType ?? '';
    const fuel = raw?.status?.energyLevel ?? raw?.status?.fuelLevel ?? raw?.fuel ?? raw?.fuelLevel ?? raw?.battery ?? raw?.batteryLevel ?? raw?.charge ?? raw?.percent ?? raw?.stateOfCharge ?? raw?.fuel_percent;

    return {
      id, plate,
      model: String(model || '').trim(),
      fuel: (typeof fuel === 'number') ? fuel : (fuel != null && String(fuel).match(/^\d+(\.\d+)?$/) ? Number(fuel) : null),
      lat: Number(lat),
      lng: Number(lng),
      raw
    };
  }

  async function refreshCars(isInitial=false) {
    const now = Date.now();
    if (!isInitial && now - state._lastRefresh < CFG.REFRESH_COOLDOWN_MS) return;
    state._lastRefresh = now;

    setSubline(isInitial ? 'Autók betöltése…' : 'Frissítés…');
    $('btnRefresh').classList.add('loading');

    let rawCars = null;
    try {
      const text = await fetchTextAny(CFG.LIMO_CARS_URLS);
      rawCars = extractAndParseJsArray(text);
      if(!rawCars) {
         try { rawCars = JSON.parse(text); } catch {}
      }
    } catch (e) {
      setSubline('Autók: nem elérhető (CORS / hálózat)');
      showStatus('Autók betöltése nem sikerült', 'Nem sikerült letölteni az adatokat.', 6000);
      $('btnRefresh').classList.remove('loading');
      updatePills();
      renderCarList();
      return;
    }

    const list = pickArrayLike(rawCars);
    if (!list) {
      setSubline('Autók: nem lista');
      $('btnRefresh').classList.remove('loading');
      return;
    }

    // Normalize
    const cars = [];
    for (const rc of list) {
      const c = normalizeCar(rc);
      if (!c) continue;
      // Filter to Budapest-ish bounding box
      if (c.lat < 47.2 || c.lat > 47.8 || c.lng < 18.7 || c.lng > 19.6) continue;
      cars.push(c);
    }

    // Determine disappeared cars
    const newIds = new Set(cars.map(c => c.id));
    for (const oldId of state.carsById.keys()) {
      if (!newIds.has(oldId)) {
        delete state.zonesByCar[oldId];
        state.selectedCars.delete(oldId);
        state.hiddenCars.delete(oldId);
        const m = state.carsAllMarkers.get(oldId);
        if (m) {
          state.carsCluster.removeLayer(m);
          state.carsAllMarkers.delete(oldId);
        }
        const sm = state.carsSelectedMarkers.get(oldId);
        if (sm) {
          state.carsSelectedLayer.removeLayer(sm);
          state.carsSelectedMarkers.delete(oldId);
        }
      }
    }

    state.cars = cars;
    state.carsById = new Map(cars.map(c => [c.id, c]));

    setSubline(`Autók betöltve: ${cars.length}`);
    updatePills();
    saveState();

    renderCarsOnMap();
    renderHotZones();
    renderCarList();

    if (state.planActive) {
      showPlanView(state.plan, { keepFocus: true });
    } else {
      applyVisibilityRules();
    }
    $('btnRefresh').classList.remove('loading');
  }

  function pickArrayLike(x) {
    if (Array.isArray(x)) return x;
    if (x && Array.isArray(x.cars)) return x.cars;
    if (x && Array.isArray(x.vehicles)) return x.vehicles;
    if (x && Array.isArray(x.data)) return x.data;
    return null;
  }

  async function loadLimoZones() {
    let hzText = null;
    try {
      hzText = await fetchTextAny(CFG.LIMO_ZONES_URLS);
    } catch (e) {
      state.limoZonesLoaded = false;
      return;
    }
    
    let hz = extractAndParseJsArray(hzText);
    let fc = null;

    if (hz && typeof hz === 'object' && hz.type && (hz.type === 'FeatureCollection' || hz.type === 'Feature')) {
      fc = hz;
    } else if (Array.isArray(hz)) {
      const features = [];
      for (const it of hz) {
        if (!it) continue;
        if (it.cityId && CFG.BUDAPEST_CITY_ID && it.cityId !== CFG.BUDAPEST_CITY_ID) continue;
        const z = it.zone ?? it.geojson ?? it.featureCollection ?? it;
        if (z && z.type === 'FeatureCollection' && Array.isArray(z.features)) {
          for (const f of z.features) features.push(f);
        } else if (z && z.type === 'Feature') {
          features.push(z);
        }
      }
      fc = { type: 'FeatureCollection', features };
    }

    if (!fc || !fc.features || !fc.features.length) {
      state.limoZonesLoaded = false;
      return;
    }

    if (state.limoZones) {
      try { state.zoneLayer.removeLayer(state.limoZones); } catch {}
    }

    state.limoZones = L.geoJSON(fc, {
      style: (feature) => {
        const t = feature?.properties?.type; // allowed / forbidden
        const isAllowed = (t === 'allowed');
        return {
          color: isAllowed ? 'rgba(34,197,94,.85)' : 'rgba(239,68,68,.85)',
          weight: 2,
          fillColor: isAllowed ? 'rgba(34,197,94,.25)' : 'rgba(239,68,68,.28)',
          fillOpacity: isAllowed ? 0.18 : 0.22,
        };
      },
      interactive: false
    });

    state.limoZonesLoaded = true;
    if (state.zonesOn) state.zoneLayer.addLayer(state.limoZones);
  }

  function setZonesOn(on, silent=false) {
    state.zonesOn = !!on;
    const el = $('toggleZones');
    el.classList.toggle('on', state.zonesOn);
    el.setAttribute('aria-checked', state.zonesOn);
    if (state.limoZonesLoaded && state.limoZones) {
      if (state.zonesOn) state.zoneLayer.addLayer(state.limoZones);
      else state.zoneLayer.removeLayer(state.limoZones);
    }
    if (!silent) saveState();
  }

  function setBkvOn(on, silent=false) {
    state.bkvOn = !!on;
    const el = $('toggleBkv');
    el.classList.toggle('on', state.bkvOn);
    el.setAttribute('aria-checked', state.bkvOn);
    if (!silent) saveState();

    if (state.bkvOn && !(window.GTFS && window.GTFS.isReady && window.GTFS.isReady())) {
      showStatus('BKV mód', 'GTFS háló nincs előkészítve (gtfs/graph.json).', 5000);
      state.bkvOn = false;
      el.classList.remove('on');
      if (!silent) saveState();
    }
  }

  // ----------------------- Rendering: cars -----------------------
  function carIcon(isSelected=false) {
    const ring = isSelected ? `box-shadow:0 0 0 3px rgba(255,176,0,.35);` : '';
    const border = isSelected ? 'border:2px solid rgba(255,176,0,.85);' : 'border:1px solid rgba(255,255,255,.18);';
    return L.divIcon({
      className: '',
      html: `<div style="
        width:44px;height:44px;border-radius:16px;
        background:rgba(17,24,39,.92);
        ${border}
        ${ring}
        box-shadow:0 18px 40px rgba(0,0,0,.45);
        display:flex;align-items:center;justify-content:center;
      ">
        <div style="
          width:22px;height:22px;border-radius:8px;
          background:rgba(255,255,255,.10);
          display:flex;align-items:center;justify-content:center;
          border:1px solid rgba(255,255,255,.12);
        ">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="white" opacity=".9" aria-hidden="true">
            <path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.22.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z"/>
          </svg>
        </div>
      </div>`,
      iconSize: [44,44],
      iconAnchor: [22,22],
    });
  }

  function renderCarsOnMap() {
    // Diff update: only add new, remove old
    for (const c of state.cars) {
      if (!state.carsAllMarkers.has(c.id)) {
        const m = L.marker([c.lat, c.lng], { icon: carIcon(false) });
        m.carId = c.id;
        m.on('click', () => onCarClick(c.id));
        state.carsAllMarkers.set(c.id, m);
        state.carsCluster.addLayer(m);
      } else {
        // update pos if moved? usually not needed for Limo cars often
        // const m = state.carsAllMarkers.get(c.id);
        // m.setLatLng([c.lat, c.lng]);
      }
    }
    // Selected markers
    for (const id of state.selectedCars) {
      const c = state.carsById.get(id);
      if (c && !state.carsSelectedMarkers.has(id)) {
        const m = L.marker([c.lat, c.lng], { icon: carIcon(true), zIndexOffset: 1000 });
        m.carId = id;
        m.on('click', () => onCarClick(id));
        state.carsSelectedMarkers.set(id, m);
        state.carsSelectedLayer.addLayer(m);
      }
    }
  }

  function onCarClick(id) {
    if (state.planActive) {
      // If user clicks a car while plan is active, maybe switch to it?
      // For now, let's just select it.
    }
    state.activeCarId = id;
    if (!state.selectedCars.has(id)) {
      toggleCarSelection(id, true);
    }
    showStatus('Kijelölve', state.carsById.get(id)?.plate);
    updatePills();
    renderHotZones(); // refresh active lines
  }

  function toggleCarSelection(id, selected) {
    if (selected) {
      state.selectedCars.add(id);
      // Remove from cluster, add to selected layer
      const m = state.carsAllMarkers.get(id);
      if (m) state.carsCluster.removeLayer(m);
      
      if (!state.carsSelectedMarkers.has(id)) {
        const c = state.carsById.get(id);
        const sm = L.marker([c.lat, c.lng], { icon: carIcon(true), zIndexOffset: 1000 });
        sm.carId = id;
        sm.on('click', () => onCarClick(id));
        state.carsSelectedLayer.addLayer(sm);
        state.carsSelectedMarkers.set(id, sm);
      }
    } else {
      state.selectedCars.delete(id);
      const sm = state.carsSelectedMarkers.get(id);
      if (sm) {
        state.carsSelectedLayer.removeLayer(sm);
        state.carsSelectedMarkers.delete(id);
      }
      const m = state.carsAllMarkers.get(id);
      if (m) state.carsCluster.addLayer(m);
      
      delete state.zonesByCar[id]; // remove zones too
    }
    saveState();
    updatePills();
    spreadSelectedCars();
    renderHotZones();
    renderCarList(); // update checkboxes
  }

  function showAllCars() {
    state.hiddenCars.clear();
    // state.selectedCars.clear(); // keep selection?
    applyVisibilityRules();
    showStatus('Összes autó', 'Szűrők törölve.');
    saveState();
  }

  function updatePills() {
    $('pillCars').textContent = `Autók: ${state.cars.length}`;
    $('pillSelected').textContent = `Kijelölt: ${state.selectedCars.size}`;
    let targets = 0;
    for (const k in state.zonesByCar) targets += state.zonesByCar[k].length;
    $('pillTargets').textContent = `Hot zone: ${targets}`;
    
    // Nearest info
    if (state.me) {
      // ... (optional calc)
    }
  }

  // ----------------------- Hot zones -----------------------
  function onMapClick(e) {
    if (!state.activeCarId || !state.selectedCars.has(state.activeCarId)) return;
    
    // Add zone target
    const c = state.carsById.get(state.activeCarId);
    if (!c) return;

    if (!state.zonesByCar[state.activeCarId]) state.zonesByCar[state.activeCarId] = [];
    const list = state.zonesByCar[state.activeCarId];
    
    // Limit
    if (list.length >= 3) {
      showStatus('Limit', 'Max 3 zóna autónként.');
      return;
    }

    list.push({
      lat: e.latlng.lat,
      lng: e.latlng.lng,
      idx: Date.now()
    });

    saveState();
    renderHotZones();
    planNow(); // auto replan
  }

  function renderHotZones() {
    state.hotZoneLayer.clearLayers();
    
    const carIds = Object.keys(state.zonesByCar);
    for (const cid of carIds) {
      if (!state.selectedCars.has(cid)) continue;
      const zones = state.zonesByCar[cid];
      const car = state.carsById.get(cid);
      if (!car || !zones) continue;

      for (const z of zones) {
        // Circle
        L.circle([z.lat, z.lng], {
          radius: state.hotRadius,
          color: '#ef4444', weight: 1, dashArray: '4 4',
          fillColor: '#ef4444', fillOpacity: 0.15,
          interactive: false
        }).addTo(state.hotZoneLayer);

        // Line
        L.polyline([[car.lat, car.lng], [z.lat, z.lng]], {
          color: '#ef4444', weight: 2, opacity: 0.5, dashArray: '5 5'
        }).addTo(state.hotZoneLayer);

        // Label
        const icon = L.divIcon({
          className: 'target-label',
          html: `<div><small>${car.plate}</small> cél</div>`
        });
        const m = L.marker([z.lat, z.lng], { icon }).addTo(state.hotZoneLayer);
        m.on('click', () => removeZone(cid, z.idx));
      }
    }
  }

  function removeZone(cid, idx) {
    if (!state.zonesByCar[cid]) return;
    state.zonesByCar[cid] = state.zonesByCar[cid].filter(z => z.idx !== idx);
    if (state.zonesByCar[cid].length === 0) delete state.zonesByCar[cid];
    saveState();
    renderHotZones();
    planNow();
  }

  // ----------------------- List & Drawer -----------------------
  function toggleDrawer(force) {
    const d = $('drawer');
    const isShow = typeof force === 'boolean' ? force : !d.classList.contains('show');
    d.classList.toggle('show', isShow);
    if (isShow) renderCarList();
  }

  function renderCarList() {
    const list = $('carList');
    list.innerHTML = '';
    
    const term = $('carSearch').value.toLowerCase().trim();
    // Sort: selected first, then dist from me? for now just list
    
    // Performance: limit render
    let count = 0;
    const MAX = 60;

    const items = [];
    for (const c of state.cars) {
      if (term && !c.plate.toLowerCase().includes(term) && !c.model.toLowerCase().includes(term)) continue;
      items.push(c);
    }
    
    // Sort selected to top
    items.sort((a,b) => {
        const s1 = state.selectedCars.has(a.id);
        const s2 = state.selectedCars.has(b.id);
        if (s1 && !s2) return -1;
        if (!s1 && s2) return 1;
        return 0;
    });

    for (const c of items) {
      if (count++ > MAX) break;
      
      const div = document.createElement('div');
      div.className = 'carItem';
      
      const isSel = state.selectedCars.has(c.id);
      
      div.innerHTML = `
        <div class="carLeft">
          <input type="checkbox" class="chk" ${isSel ? 'checked' : ''}>
          <div class="carMain">
            <div class="plate">${c.plate}</div>
            <div class="carMeta">${c.model} • ${c.fuel}%</div>
            ${isSel ? '<div class="tag">Kijelölve</div>' : ''}
          </div>
        </div>
        <div class="carBtns">
           <button class="btn ghost small">Mutat</button>
        </div>
      `;

      // Events
      const chk = div.querySelector('.chk');
      chk.onclick = (e) => { e.stopPropagation(); toggleCarSelection(c.id, chk.checked); };
      
      const btn = div.querySelector('button');
      btn.onclick = (e) => { 
        e.stopPropagation(); 
        toggleDrawer(false); 
        state.map.setView([c.lat, c.lng], 16); 
        onCarClick(c.id); 
      };

      div.onclick = () => { chk.click(); };

      list.appendChild(div);
    }
    
    $('drawerSub').textContent = `Összesen: ${state.cars.length}`;
  }

  // ----------------------- Planning -----------------------
  
  // Debounced plan call
  const planNow = debounce(async (force) => {
    if (!force && !state.planActive) return;
    
    // Gather targets
    const tasks = [];
    
    // Check if we have selected cars
    const selectedIds = [...state.selectedCars];
    if (!selectedIds.length) {
      if (force) showStatus('Tervezés', 'Nincs kijelölt autó.');
      return;
    }
    
    if (!state.me) {
      if (force) showStatus('GPS', 'Nincs pozíció.');
      return;
    }

    // Sort selected cars by distance to me?
    // For now, take the first one or active one
    let carId = state.activeCarId;
    if (!carId || !state.selectedCars.has(carId)) carId = selectedIds[0];
    
    const car = state.carsById.get(carId);
    
    // 1. Walk to Car
    const walkRes = await fetchRoute('foot', state.me, { lat: car.lat, lng: car.lng });
    
    // 2. Drive to Zone (if exists)
    let driveRes = null;
    let zone = null;
    if (state.zonesByCar[car.id] && state.zonesByCar[car.id].length > 0) {
        zone = state.zonesByCar[car.id][0];
        driveRes = await fetchRoute('car', { lat: car.lat, lng: car.lng }, zone);
    }

    state.plan = { car, walkRes, driveRes, zone };
    state.planActive = true;
    showPlanView(state.plan);

  }, CFG.AUTOPLAN_DEBOUNCE_MS);


  async function fetchRoute(mode, from, to) {
    // Cache key
    const k = `${mode}:${from.lat.toFixed(4)},${from.lng.toFixed(4)}:${to.lat.toFixed(4)},${to.lng.toFixed(4)}`;
    if (state.osrmCache.has(k)) return state.osrmCache.get(k);

    const baseUrl = (mode === 'foot') ? CFG.OSRM_FOOT[0] : CFG.OSRM_CAR[0];
    const url = `${baseUrl}/route/v1/driving/${from.lng},${from.lat};${to.lng},${to.lat}?overview=full&geometries=geojson`;
    
    try {
        const r = await fetch(url);
        if(!r.ok) return null;
        const j = await r.json();
        if(!j.routes || !j.routes.length) return null;
        
        const res = {
            dist: j.routes[0].distance,
            dur: j.routes[0].duration,
            geo: j.routes[0].geometry
        };
        state.osrmCache.set(k, res);
        return res;
    } catch(e) {
        console.error(e);
        return null;
    }
  }

  function showPlanView(plan, opts={}) {
    if (!plan) return;
    const { car, walkRes, driveRes, zone } = plan;

    // Hide others
    state.hiddenCars = new Set(state.cars.map(c => c.id));
    state.hiddenCars.delete(car.id);
    applyVisibilityRules();

    // Draw lines
    state.routeLayer.clearLayers();
    
    if (walkRes) {
        L.geoJSON(walkRes.geo, { style: { color: '#4ade80', weight: 4, dashArray: '1 6' } }).addTo(state.routeLayer);
    }
    if (driveRes) {
        L.geoJSON(driveRes.geo, { style: { color: '#ffb000', weight: 4 } }).addTo(state.routeLayer);
    }

    // Show Sheet
    $('sheet').classList.add('show');
    $('sheetTitle').textContent = car.plate;
    $('sheetSub').textContent = car.model;

    const steps = $('steps');
    steps.innerHTML = '';

    // Step 1: Walk
    if (walkRes) {
        steps.innerHTML += `
        <div class="step">
            <div class="badge" style="background:#4ade80; color:#000;">1</div>
            <div>
                <div class="stepTitle">Séta az autóhoz</div>
                <div class="stepMeta">${fmtKm(walkRes.dist)} • ${fmtMin(walkRes.dur)}</div>
            </div>
        </div>`;
    }

    // Step 2: Drive
    if (driveRes) {
        steps.innerHTML += `
        <div class="step">
            <div class="badge" style="background:#ffb000; color:#000;">2</div>
            <div>
                <div class="stepTitle">Vezetés a zónához</div>
                <div class="stepMeta">${fmtKm(driveRes.dist)} • ${fmtMin(driveRes.dur)}</div>
            </div>
        </div>`;
    }
    
    if (!opts.keepFocus && walkRes) {
        const b = L.geoJSON(walkRes.geo).getBounds();
        if(driveRes) b.extend(L.geoJSON(driveRes.geo).getBounds());
        state.map.fitBounds(b, { padding: [50,50] });
    }
  }

  function clearPlanView() {
    state.planActive = false;
    state.plan = null;
    state.routeLayer.clearLayers();
    $('sheet').classList.remove('show');
    showAllCars();
  }

  function applyVisibilityRules() {
    state.carsCluster.clearLayers();
    for (const c of state.cars) {
      if (state.hiddenCars.has(c.id)) {
         // skip
      } else {
         const m = state.carsAllMarkers.get(c.id);
         if (m) state.carsCluster.addLayer(m);
      }
    }
  }

  function spreadSelectedCars() {
     // Spiderfy logic placeholder
  }

  // Init
  initMap();

})();
</script>
</body>
</html>
