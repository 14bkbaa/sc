<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />
  <title>Carsharing tervez≈ë</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin="anonymous">

  <style>
    :root{
      --bg: rgba(12,18,28,.88);
      --bg2: rgba(12,18,28,.74);
      --text: #f3f7ff;
      --muted: rgba(243,247,255,.68);
      --line: rgba(255,255,255,.10);
      --accent: #ffb000;
      --good: #16a34a;
      --bad: #dc2626;
      --chip: rgba(255,255,255,.10);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --r: 16px;
    }
    html, body { height: 100%; margin: 0; }
    body {
      background:#000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
    }
    #map { position: fixed; inset: 0; }

    .hud{
      position: fixed;
      z-index: 1000;
      left: 10px; top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: min(560px, calc(100vw - 20px));
      pointer-events: none;
    }
    .card{
      pointer-events: auto;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      overflow: hidden;
    }
    .row{ display:flex; gap:8px; align-items:center; }
    .pad{ padding: 10px; }
    .title{ font-weight: 800; font-size: 14px; letter-spacing: .2px; }
    .sub{ font-size: 12px; color: var(--muted); }
    .btn{
      appearance: none; border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight: 800;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      touch-action: manipulation;
    }
    .btn:active{ transform: scale(.99); }
    .btn.primary{ border-color: rgba(22,163,74,.55); background: rgba(22,163,74,.20); }
    .btn.danger{ border-color: rgba(220,38,38,.55); background: rgba(220,38,38,.18); }
    .btn.warn{ border-color: rgba(255,176,0,.55); background: rgba(255,176,0,.18); }
    .btn.ghost{ background: transparent; }
    .btn.small{ padding: 8px 10px; font-size: 12px; }

    .toggle{
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      display:flex; gap:8px; align-items:center;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    .dot{ width:10px; height:10px; border-radius: 999px; background: rgba(255,255,255,.25); }
    .toggle.on .dot{ background: var(--accent); }

    /* Drawer */
    .drawer{
      position: fixed; z-index: 1300;
      right: 10px; top: 10px;
      width: min(440px, calc(100vw - 20px));
      max-height: min(84vh, 780px);
      display:none;
    }
    .drawer.show{ display:block; }
    .drawerHeader{
      padding: 10px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.30);
    }
    .drawerBody{ max-height: calc(min(84vh, 780px) - 52px); overflow: auto; padding: 10px 10px; }
    .search{
      width: 100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.28);
      color: var(--text);
      outline: none;
      font-size: 14px;
    }

    .carItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 10px 8px;
      border-bottom: 1px dashed rgba(255,255,255,.12);
    }
    .carItem.active{
      background: rgba(255,176,0,.08);
      border-bottom-color: rgba(255,176,0,.25);
    }
    .carLeft{ display:flex; gap:10px; align-items:flex-start; min-width: 0; }
    .chk{
      width: 22px; height: 22px;
      accent-color: var(--accent);
      flex: 0 0 auto;
      margin-top: 1px;
    }
    .carMain{ min-width: 0; cursor: pointer; }
    .plate{ font-weight: 900; letter-spacing: .6px; }
    .carMeta{
      font-size: 12px;
      color: rgba(255,255,255,.72);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      font-size: 11px;
      color: rgba(255,255,255,.80);
      margin-top: 6px;
      gap:6px;
    }
    .carBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .carBtns .btn{ padding: 8px 10px; font-size: 12px; }

    /* Plan sheet */
    .sheet{
      position: fixed; z-index: 1100;
      left: 10px; right: 10px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      max-width: 980px;
      margin: 0 auto;
      border-radius: 18px;
      overflow: hidden;
      display:none;
    }
    .sheet.show{ display:block; }
    .sheetHeader{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding: 12px 12px;
      background: rgba(0,0,0,.55);
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .sheetHeader .title{ font-size: 14px; }
    .sheetBody{
      max-height: min(56vh, 540px);
      overflow: auto;
      padding: 10px 12px;
    }
    .steps{ display:flex; flex-direction:column; gap:10px; }
    .step{
      padding: 10px 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      display:flex; gap:10px; align-items:flex-start;
    }
    .badge{
      min-width: 28px; height: 28px;
      border-radius: 999px;
      display:flex; align-items:center; justify-content:center;
      font-weight: 900;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.12);
      flex: 0 0 auto;
    }
    .stepTitle{ font-weight: 900; }
    .stepMeta{ font-size: 12px; color: rgba(255,255,255,.76); margin-top: 4px; line-height: 1.35; }

    /* Bottom status strip */
    .statusbar{
      position: fixed; z-index: 1200;
      left: 0; right: 0; bottom: 0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: rgba(0,0,0,.86);
      color: #fff;
      font-size: 13px;
      line-height: 1.35;
      border-top: 1px solid rgba(255,255,255,.12);
      display:none;
    }
    .statusbar.show{ display:block; }
    .statusbar b{ font-size: 14px; }
    .statusbar .muted{ color: rgba(255,255,255,.7); }

    /* Zone editor */
    .zoneEditor{
      position: fixed;
      z-index: 1400;
      left: 10px; right: 10px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      max-width: 720px;
      margin: 0 auto;
      display:none;
    }
    .zoneEditor.show{ display:block; }
    .zoneEditor .pad{ padding: 10px; }
    .zoneEditor .row{ justify-content: space-between; }
    .zoneEditor .actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }

    /* Marker labels */
    .plate-label{
      background: rgba(0,0,0,.70);
      color: #fff;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 4px 8px;
      font-weight: 900;
      font-size: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      pointer-events: none;
      white-space: nowrap;
    }
    .target-label{
      background: rgba(220,38,38,.92);
      color: #fff;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,.18);
      font-weight: 900;
      font-size: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      white-space: nowrap;
    }
    .target-label small{ font-weight: 900; opacity: .9; }

    @media (max-width: 720px){
      .hud{ left: 8px; right: 8px; top: 8px; max-width: calc(100vw - 16px); }
      .drawer{
        right: 8px; left: 8px;
        top: auto;
        bottom: calc(8px + env(safe-area-inset-bottom));
        width: auto;
        max-height: min(78vh, 720px);
        border-radius: 18px;
      }
      .drawerBody{ max-height: calc(min(78vh, 720px) - 52px); }
      .sheet{
        left: 8px; right: 8px;
        bottom: calc(8px + env(safe-area-inset-bottom));
        border-radius: 18px;
      }
      .sheetBody{ max-height: min(60vh, 560px); }
      .zoneEditor{ left: 8px; right: 8px; bottom: calc(8px + env(safe-area-inset-bottom)); }
      .btn{ padding: 12px 14px; font-size: 14px; }
      .btn.small{ padding: 10px 12px; font-size: 13px; }
      .toggle{ padding: 12px 14px; }
      .chk{ width: 24px; height: 24px; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- HUD -->
  <div class="hud">
    <div class="card pad">
      <div class="row" style="justify-content:space-between; align-items:flex-start;">
        <div>
          <div class="title">Carsharing tervez≈ë</div>
          <div class="sub" id="subLine">Bet√∂lt√©s‚Ä¶</div>
        </div>
        <div class="row" style="gap:6px; flex-wrap:wrap; justify-content:flex-end;">
          <button class="btn small ghost" id="btnCars">Aut√≥k</button>
          <button class="btn small" id="btnRefresh">Friss√≠t√©s</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px; flex-wrap:wrap;">
        <button class="btn primary" id="btnPlan">Tervez√©s</button>
        <button class="btn warn" id="btnClearSel">Kijel√∂l√©sek t√∂rl√©se</button>

        <div class="toggle" id="toggleZones" title="MOL Limo z√≥n√°k">
          <div class="dot"></div><div style="font-weight:900; font-size:13px;">Z√≥n√°k</div>
        </div>
        <div class="toggle" id="toggleBkv" title="BKV (GTFS graph.json sz√ºks√©ges)">
          <div class="dot"></div><div style="font-weight:900; font-size:13px;">BKV</div>
        </div>

        <button class="btn small" id="btnExitActive" style="display:none;">√ñsszes</button>
        <button class="btn small ghost" id="btnShowPlan" style="display:none;">Terv</button>
      </div>
    </div>
  </div>

  <!-- Drawer -->
  <div class="drawer card" id="drawer">
    <div class="drawerHeader">
      <div>
        <div class="title">Aut√≥k</div>
        <div class="sub" id="drawerSub">‚Äî</div>
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap; justify-content:flex-end;">
        <button class="btn small" id="btnCloseDrawer">Bez√°r</button>
      </div>
    </div>
    <div class="drawerBody">
      <input class="search" id="carSearch" placeholder="Keres√©s (rendsz√°m / t√≠pus)..." />
      <div style="height:10px;"></div>
      <div id="carList"></div>
      <div style="height:10px;"></div>
      <div class="sub">
        Tipp: pip√°ld ki az aut√≥t ‚Üí kattints r√° (list√°ban vagy t√©rk√©pen) ‚Üí t√©rk√©pre katt = hot zone.
      </div>
    </div>
  </div>

  <!-- Plan sheet -->
  <div class="sheet card" id="sheet">
    <div class="sheetHeader">
      <div>
        <div class="title" id="sheetTitle">K√©sz</div>
        <div class="sub" id="sheetSub">‚Äî</div>
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap; justify-content:flex-end;">
        <button class="btn small" id="btnMinSheet">Csuk</button>
        <button class="btn small" id="btnReplan">√öjratervez√©s</button>
        <button class="btn small danger" id="btnClosePlan">Bez√°r</button>
      </div>
    </div>
    <div class="sheetBody">
      <div class="steps" id="steps"></div>
    </div>
  </div>

  <!-- Zone editor -->
  <div class="zoneEditor card" id="zoneEditor">
    <div class="pad">
      <div class="row">
        <div style="min-width:0;">
          <div class="title" id="zeTitle">Hot zone</div>
          <div class="sub" id="zeSub">‚Äî</div>
        </div>
        <div class="actions">
          <button class="btn warn small" id="btnMoveZone">√Åthelyez√©s</button>
          <button class="btn danger small" id="btnDeleteZone">T√∂rl√©s</button>
          <button class="btn small" id="btnCloseZoneEditor">M√©gse</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Status bar -->
  <div class="statusbar" id="statusbar">
    <b id="statusTitle">‚Äî</b><br>
    <span class="muted" id="statusText">‚Äî</span>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin="anonymous"></script>

  <script>
/* -------- GTFS helper (opcion√°lis) --------
   V√°r: ./gtfs/graph.json
   {
     "stops":[{"id":"..","name":"..","lat":..,"lon":..},...],
     "edges":[{"from":0,"to":1,"w":180,"route":"4-6","type":0}, ...]
   }
*/
(() => {
  'use strict';

  const GTFS = {
    _ready: false,
    _stops: null,
    _edges: null,
    _adj: null,

    async init() {
      try {
        const r = await fetch('./gtfs/graph.json', { cache: 'force-cache' });
        if (!r.ok) return false;
        const j = await r.json();
        if (!j || !Array.isArray(j.stops) || !Array.isArray(j.edges)) return false;

        GTFS._stops = j.stops;
        GTFS._edges = j.edges;

        GTFS._adj = Array.from({ length: GTFS._stops.length }, () => []);
        for (let idx = 0; idx < GTFS._edges.length; idx++) {
          const e = GTFS._edges[idx];
          if (typeof e.from !== 'number' || typeof e.to !== 'number' || typeof e.w !== 'number') continue;
          GTFS._adj[e.from].push({
            to: e.to,
            w: e.w,
            route: e.route ?? null,
            type: e.type ?? null,
            idx
          });
        }

        GTFS._ready = true;
        return true;
      } catch {
        return false;
      }
    },

    isReady() { return GTFS._ready; },

    nearestStops(pt, k = 6, maxM = 1200) {
      if (!GTFS._ready) return [];
      const res = [];
      for (let i = 0; i < GTFS._stops.length; i++) {
        const s = GTFS._stops[i];
        const d = haversineM(pt.lat, pt.lng, s.lat, s.lon);
        if (d <= maxM) res.push({ i, d });
      }
      res.sort((a,b)=>a.d-b.d);
      return res.slice(0, k);
    },

    // Dijkstra multiple sources, returns walking+transit estimate and stop-chain meta
    async plan(from, to, opt = {}) {
      if (!GTFS._ready) return null;

      const maxWalk = opt.maxWalkToStopM ?? 900;
      const startStops = GTFS.nearestStops(from, 8, maxWalk);
      const endStops = GTFS.nearestStops(to, 8, maxWalk);
      if (!startStops.length || !endStops.length) return null;

      const walkSpeed = 1.25; // m/s
      const walkCost = (m) => m / walkSpeed;

      const N = GTFS._stops.length;
      const dist = new Float64Array(N);
      const prev = new Int32Array(N);
      const prevEdgeIdx = new Int32Array(N);
      for (let i=0;i<N;i++){ dist[i]=Infinity; prev[i]=-1; prevEdgeIdx[i]=-1; }

      // Binary heap
      const heap = [];
      const push = (d, i) => { heap.push([d,i]); siftUp(heap.length-1); };
      const pop = () => {
        if (!heap.length) return null;
        const top = heap[0];
        const last = heap.pop();
        if (heap.length) { heap[0]=last; siftDown(0); }
        return top;
      };
      const siftUp = (idx) => {
        while (idx>0){
          const p=(idx-1)>>1;
          if (heap[p][0] <= heap[idx][0]) break;
          [heap[p],heap[idx]]=[heap[idx],heap[p]];
          idx=p;
        }
      };
      const siftDown = (idx) => {
        for(;;){
          const l=idx*2+1, r=l+1;
          let s=idx;
          if (l<heap.length && heap[l][0] < heap[s][0]) s=l;
          if (r<heap.length && heap[r][0] < heap[s][0]) s=r;
          if (s===idx) break;
          [heap[s],heap[idx]]=[heap[idx],heap[s]];
          idx=s;
        }
      };

      for (const ss of startStops) {
        dist[ss.i] = walkCost(ss.d);
        push(dist[ss.i], ss.i);
      }

      const endSet = new Set(endStops.map(x => x.i));
      let bestEnd = null;

      while (heap.length) {
        const item = pop();
        if (!item) break;
        const [d,u] = item;
        if (d !== dist[u]) continue;
        if (endSet.has(u)) { bestEnd = u; break; }

        const adj = GTFS._adj[u];
        for (let k=0; k<adj.length; k++){
          const e = adj[k];
          const nd = d + e.w;
          if (nd < dist[e.to]) {
            dist[e.to] = nd;
            prev[e.to] = u;
            prevEdgeIdx[e.to] = e.idx;
            push(nd, e.to);
          }
        }
      }

      if (bestEnd == null) return null;

      // choose end walking distance for this bestEnd
      const endChoice = endStops.reduce((a,x)=> (x.i===bestEnd && x.d < (a?.d ?? Infinity)) ? x : a, null)
        || endStops[0];

      const total = dist[bestEnd] + walkCost(endChoice.d);

      // Rebuild stop chain
      const chain = [];
      let cur = bestEnd;
      chain.push(cur);
      while (prev[cur] !== -1) { cur = prev[cur]; chain.push(cur); }
      chain.reverse();

      // Collect routes used (in order, compressed)
      const routes = [];
      for (let i = 1; i < chain.length; i++){
        const stop = chain[i];
        const eIdx = prevEdgeIdx[stop];
        const r = (eIdx >= 0 && GTFS._edges[eIdx]) ? (GTFS._edges[eIdx].route ?? null) : null;
        if (!r) continue;
        if (!routes.length || routes[routes.length-1] !== r) routes.push(String(r));
      }
      const uniqueRoutes = [];
      for (const r of routes) if (!uniqueRoutes.includes(r)) uniqueRoutes.push(r);

      const boardStop = GTFS._stops[chain[0]]?.name ?? '‚Äî';
      const alightStop = GTFS._stops[chain[chain.length-1]]?.name ?? '‚Äî';

      // via points: from + sampled stops + to
      const maxStopsForGeometry = 18;
      const sampled = [];
      if (chain.length <= maxStopsForGeometry) {
        for (const idx of chain) sampled.push(GTFS._stops[idx]);
      } else {
        const step = Math.ceil(chain.length / maxStopsForGeometry);
        for (let i=0;i<chain.length;i+=step) sampled.push(GTFS._stops[chain[i]]);
        if (sampled[sampled.length-1] !== GTFS._stops[chain[chain.length-1]]) sampled.push(GTFS._stops[chain[chain.length-1]]);
      }

      const viaPoints = [];
      viaPoints.push({ lat: from.lat, lng: from.lng });
      for (const s of sampled) viaPoints.push({ lat: s.lat, lng: s.lon });
      viaPoints.push({ lat: to.lat, lng: to.lng });

      return {
        totalDuration: total,
        totalDistance: null,
        viaPoints,
        meta: {
          boardStop,
          alightStop,
          routes: uniqueRoutes,
          stops: chain.length
        }
      };
    }
  };

  function haversineM(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = (d) => d*Math.PI/180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }

  window.GTFS = GTFS;
})();
  </script>

  <script>
(() => {
  'use strict';

  const CFG = {
    LIMO_CARS_URLS: [
      'https://mollimo.hu/data/cars.js?u7XOvp6hNn',
      'https://mollimo.hu/data/cars.js',
    ],
    LIMO_ZONES_URLS: [
      'https://mollimo.hu/data/homezones.js?UtaHbFc6QF',
      'https://mollimo.hu/data/homezones.js',
    ],
    BUDAPEST_CITY_ID: '8ee26110-d8e9-4e0d-b4b7-e76fd4e00459',

    OSRM_FOOT: ['https://routing.openstreetmap.de/routed-foot'],
    OSRM_CAR:  ['https://routing.openstreetmap.de/routed-car','https://router.project-osrm.org'],

    HOTZONE_RADIUS_M: 360,
    HOTZONE_RADIUS_MIN: 300,
    HOTZONE_RADIUS_MAX: 400,

    TRANSIT_MAX_WALK_TO_STOP_M: 900,

    DEFAULT_CENTER: [47.4979, 19.0402],
    DEFAULT_ZOOM: 12,

    STORAGE_KEY: 'streetcrowd_planner_v6',
    REFRESH_COOLDOWN_MS: 1200,
  };

  const $ = (id) => document.getElementById(id);

  function showStatus(title, text, ms = 2400) {
    const bar = $('statusbar');
    $('statusTitle').textContent = title || '‚Äî';
    $('statusText').textContent = text || '‚Äî';
    bar.classList.add('show');
    if (ms > 0) {
      clearTimeout(showStatus._t);
      showStatus._t = setTimeout(() => bar.classList.remove('show'), ms);
    }
  }
  function setSubline(text) { $('subLine').textContent = text; }
  function clampNumber(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function fmtKm(m) {
    if (m == null || !isFinite(m)) return '‚Äî';
    return (m/1000).toFixed(m >= 10000 ? 0 : 2) + ' km';
  }
  function fmtMin(s) {
    const min = Math.max(0, Math.round(s/60));
    if (min < 60) return `${min} perc`;
    const h = Math.floor(min/60);
    const m = min % 60;
    return `${h} √≥ ${m} p`;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));
  }

  function haversineM(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = (d) => d*Math.PI/180;
    const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }

  // ---------- Storage ----------
  function loadState() {
    try {
      const raw = localStorage.getItem(CFG.STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }
  function saveState() {
    try {
      const st = {
        selected: Array.from(state.selectedCars),
        activeCarId: state.activeCarId,
        zonesByCar: state.zonesByCar,
        hotRadius: state.hotRadius,
        ui: {
          zonesOn: state.zonesOn,
          bkvOn: state.bkvOn
        }
      };
      localStorage.setItem(CFG.STORAGE_KEY, JSON.stringify(st));
    } catch {}
  }

  // ---------- Global state ----------
  const state = {
    map: null,
    tiles: null,

    carsLayer: null,
    labelLayer: null,
    zoneLayer: null,
    hotZoneLayer: null,
    routeLayer: null,

    cars: [],
    carsById: new Map(),
    carMarkers: new Map(),     // id -> marker
    carLabelMarkers: new Map(),// id -> label marker

    me: null,
    meMarker: null,

    limoZones: null,
    limoZonesLoaded: false,

    selectedCars: new Set(),
    activeCarId: null,
    zonesByCar: {},

    hotRadius: CFG.HOTZONE_RADIUS_M,
    zonesOn: false,
    bkvOn: false,

    planActive: false,
    plan: null,
    sheetMinimized: false,

    moveZone: null, // {carId, zoneIndex}
    editingZone: null, // {carId, zoneIndex}

    _lastRefresh: 0,

    osrmCache: new Map(),
    elevationCache: new Map(),
  };

  // ---------- Plan invalidation ----------
  function invalidatePlan(reason) {
    if (!state.planActive) return;
    clearPlan({ silent: true });
    showStatus('Terv t√∂r√∂lve', reason || 'M√≥dos√≠tott√°l valamit, ez√©rt a terv automatikusan t√∂rl≈ëd√∂tt.', 3200);
  }

  // ---------- Map init ----------
  function initMap() {
    const map = L.map('map', {
      zoomControl: true,
      preferCanvas: true
    }).setView(CFG.DEFAULT_CENTER, CFG.DEFAULT_ZOOM);

    state.tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap',
      crossOrigin: true,
    }).addTo(map);

    state.carsLayer = L.markerClusterGroup({
      showCoverageOnHover: false,
      spiderfyOnMaxZoom: true,
      maxClusterRadius: 50,
      disableClusteringAtZoom: 18,
    }).addTo(map);

    state.labelLayer = L.layerGroup().addTo(map);
    state.zoneLayer = L.layerGroup().addTo(map);
    state.hotZoneLayer = L.layerGroup().addTo(map);
    state.routeLayer = L.layerGroup().addTo(map);

    state.map = map;

    map.on('click', onMapClick);

    // UI hooks
    $('btnRefresh').addEventListener('click', () => refreshCars(false));
    $('btnCars').addEventListener('click', () => toggleDrawer(true));
    $('btnCloseDrawer').addEventListener('click', () => toggleDrawer(false));
    $('carSearch').addEventListener('input', renderCarList);

    $('btnClearSel').addEventListener('click', () => {
      invalidatePlan('Kijel√∂l√©sek m√≥dosultak.');
      state.selectedCars.clear();
      state.activeCarId = null;
      state.zonesByCar = {};
      saveState();
      renderCars();
      renderHotZones();
      renderCarList();
      updateHudButtons();
      showStatus('K√©sz', 'Kijel√∂l√©sek √©s hot zone-ok t√∂r√∂lve.', 2000);
    });

    $('toggleZones').addEventListener('click', () => {
      invalidatePlan('Z√≥n√°k kapcsol√≥ m√≥dosult.');
      setZonesOn(!state.zonesOn, false);
    });
    $('toggleBkv').addEventListener('click', () => {
      invalidatePlan('BKV kapcsol√≥ m√≥dosult.');
      setBkvOn(!state.bkvOn, false);
    });

    $('btnPlan').addEventListener('click', () => planNow());
    $('btnReplan').addEventListener('click', () => planNow());
    $('btnClosePlan').addEventListener('click', () => clearPlan({ silent:false }));
    $('btnMinSheet').addEventListener('click', () => minimizeSheet());
    $('btnShowPlan').addEventListener('click', () => showSheet());

    $('btnExitActive').addEventListener('click', () => {
      invalidatePlan('Akt√≠v aut√≥ m√≥dosult.');
      state.activeCarId = null;
      state.moveZone = null;
      closeZoneEditor();
      saveState();
      renderCars();
      renderHotZones();
      renderCarList();
      updateHudButtons();
      showStatus('N√©zet', '√ñsszes kijel√∂lt aut√≥ l√°tszik.', 1600);
    });

    // zone editor buttons
    $('btnCloseZoneEditor').addEventListener('click', () => {
      state.moveZone = null;
      closeZoneEditor();
      showStatus('K√©sz', 'Hot zone szerkeszt√©s bez√°rva.', 1200);
    });

    $('btnDeleteZone').addEventListener('click', () => {
      if (!state.editingZone) return;
      invalidatePlan('Hot zone m√≥dosult.');
      const { carId, zoneIndex } = state.editingZone;
      const zs = state.zonesByCar[carId] || [];
      zs.splice(zoneIndex, 1);
      state.zonesByCar[carId] = zs;
      // ha nincs t√∂bb hotzone, maradhat kijel√∂lve, de tervez√©shez √∫gysem sz√°m√≠t
      state.moveZone = null;
      closeZoneEditor();
      saveState();
      renderHotZones();
      renderCarList();
      showStatus('T√∂r√∂lve', `Hot zone #${zoneIndex+1} t√∂r√∂lve.`, 1600);
    });

    $('btnMoveZone').addEventListener('click', () => {
      if (!state.editingZone) return;
      invalidatePlan('Hot zone m√≥dosult.');
      state.moveZone = { ...state.editingZone };
      closeZoneEditor();
      showStatus('√Åthelyez√©s', 'Koppints a t√©rk√©pen az √∫j helyre.', 0);
    });

    // Load previous state
    const st = loadState();
    if (st) {
      state.selectedCars = new Set(st.selected || []);
      state.activeCarId = st.activeCarId || null;
      state.zonesByCar = st.zonesByCar || {};
      state.hotRadius = clampNumber(st.hotRadius ?? CFG.HOTZONE_RADIUS_M, CFG.HOTZONE_RADIUS_MIN, CFG.HOTZONE_RADIUS_MAX);
      state.zonesOn = !!(st.ui && st.ui.zonesOn);
      state.bkvOn = !!(st.ui && st.ui.bkvOn);
    }

    setZonesOn(state.zonesOn, true);
    setBkvOn(state.bkvOn, true);

    startGps();

    // initial load
    refreshCars(true);
    loadLimoZones();

    // GTFS init (optional)
    if (window.GTFS && typeof window.GTFS.init === 'function') {
      window.GTFS.init().then((ok) => {
        if (!ok) showStatus('BKV: KI', 'GTFS graph.json hi√°nyzik ‚Äì a BKV m√≥d nem el√©rhet≈ë.', 5000);
      }).catch(()=>{});
    }
  }

  // ---------- GPS ----------
  let gpsWatchId = null;
  function startGps() {
    if (!navigator.geolocation) {
      showStatus('GPS', 'A b√∂ng√©sz≈ë nem t√°mogatja a geolok√°ci√≥t.');
      return;
    }
    if (gpsWatchId != null) return;

    gpsWatchId = navigator.geolocation.watchPosition(
      (pos) => {
        const { latitude, longitude, accuracy } = pos.coords;
        state.me = { lat: latitude, lng: longitude, acc: accuracy, ts: Date.now() };
        renderMe();
      },
      (err) => {
        showStatus('GPS hiba', err.message || String(err), 4000);
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 12000 }
    );
  }

  function renderMe() {
    if (!state.me) return;
    const ll = [state.me.lat, state.me.lng];

    if (!state.meMarker) {
      const icon = L.divIcon({
        className: '',
        html: `<div style="
          width:14px;height:14px;border-radius:999px;
          background:#4ade80;
          border:3px solid rgba(0,0,0,.55);
          box-shadow:0 10px 30px rgba(0,0,0,.35);
        "></div>`,
        iconSize: [14,14],
        iconAnchor: [7,7],
      });
      state.meMarker = L.marker(ll, { icon, interactive: false }).addTo(state.labelLayer);
    } else {
      state.meMarker.setLatLng(ll);
    }
  }

  // ---------- Limo data loading (script-injection) ----------
  function loadScriptOnce(url, timeoutMs=12000) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.async = true;
      const u = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
      s.src = u;

      let done = false;
      const to = setTimeout(() => {
        if (done) return;
        done = true;
        s.remove();
        reject(new Error('Timeout: ' + url));
      }, timeoutMs);

      s.onload = () => {
        if (done) return;
        done = true;
        clearTimeout(to);
        s.remove();
        resolve();
      };
      s.onerror = () => {
        if (done) return;
        done = true;
        clearTimeout(to);
        s.remove();
        reject(new Error('Load error: ' + url));
      };

      document.head.appendChild(s);
    });
  }

  function pickArrayLike(x) {
    if (Array.isArray(x)) return x;
    if (x && Array.isArray(x.cars)) return x.cars;
    if (x && Array.isArray(x.vehicles)) return x.vehicles;
    if (x && Array.isArray(x.data)) return x.data;
    return null;
  }

  async function loadGlobalArrayAny(urls, globalName, timeoutMs=12000) {
    let lastErr = null;
    for (const u of urls) {
      try {
        try { delete window[globalName]; } catch {}
        await loadScriptOnce(u, timeoutMs);
        const arr = pickArrayLike(window[globalName]);
        if (arr) return arr;

        if (globalName === 'cars') {
          const alt = pickArrayLike(window.CARS) || pickArrayLike(window.vehicles) || pickArrayLike(window.data);
          if (alt) return alt;
        }
        if (globalName === 'homezones') {
          const alt = pickArrayLike(window.HOMEZONES) || pickArrayLike(window.zones);
          if (alt) return alt;
        }
        throw new Error('Bad format: window.' + globalName);
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error('Load failed: ' + globalName);
  }

  function carIdFromObj(o){
    return String(
      o?.description?.id ||
      o?.description?.plate ||
      o?.description?.name ||
      o?.id ||
      o?.plate ||
      o?.licensePlate ||
      o?.license_plate ||
      o?.car_id ||
      o?.code ||
      (o?.name ? o.name : '')
    ) || ('car_' + Math.random().toString(16).slice(2));
  }

  function normalizeCar(raw) {
    const lat = raw?.location?.position?.lat ?? raw?.lat ?? raw?.latitude ?? raw?.Latitude ?? raw?.LAT ?? raw?.y;
    const lng = raw?.location?.position?.lon ?? raw?.location?.position?.lng ?? raw?.lon ?? raw?.lng ?? raw?.longitude ?? raw?.Longitude ?? raw?.LNG ?? raw?.x;
    if (lat == null || lng == null) return null;

    const id = carIdFromObj(raw);
    const plate = String(raw?.description?.plate ?? raw?.description?.name ?? raw?.plate ?? raw?.licensePlate ?? raw?.license_plate ?? raw?.reg ?? id).toUpperCase().trim();
    const model = raw?.description?.model ?? raw?.model ?? raw?.type ?? raw?.carType ?? raw?.brand ?? raw?.vehicleType ?? '';

    return {
      id,
      plate,
      model: String(model || '').trim(),
      lat: Number(lat),
      lng: Number(lng),
      raw
    };
  }

  async function refreshCars(isInitial=false) {
    const now = Date.now();
    if (!isInitial && now - state._lastRefresh < CFG.REFRESH_COOLDOWN_MS) return;
    state._lastRefresh = now;

    invalidatePlan('Friss√≠t√©s t√∂rt√©nt.');

    setSubline(isInitial ? 'Aut√≥k bet√∂lt√©se‚Ä¶' : 'Friss√≠t√©s‚Ä¶');

    let rawCars = null;
    try {
      rawCars = await loadGlobalArrayAny(CFG.LIMO_CARS_URLS, 'cars', 12000);
    } catch (e) {
      setSubline('Aut√≥k: nem el√©rhet≈ë (CORS / h√°l√≥zat)');
      showStatus('Aut√≥k bet√∂lt√©se nem siker√ºlt', 'A mollimo.hu adatf√°jl nem √©rhet≈ë el innen. A t√©rk√©p m≈±k√∂dik, de aut√≥k n√©lk√ºl.', 6000);
      state.cars = [];
      state.carsById = new Map();
      renderCars();
      renderCarList();
      updateHudButtons();
      return;
    }

    if (!Array.isArray(rawCars)) {
      setSubline('Aut√≥k: nem lista');
      showStatus('cars.js', 'Az adat nem t√∂mb.', 5000);
      return;
    }

    const cars = [];
    for (const rc of rawCars) {
      const c = normalizeCar(rc);
      if (!c) continue;
      if (c.lat < 47.2 || c.lat > 47.8 || c.lng < 18.7 || c.lng > 19.6) continue;
      cars.push(c);
    }

    // cleanup disappeared
    const newIds = new Set(cars.map(c => c.id));
    for (const oldId of state.carsById.keys()) {
      if (!newIds.has(oldId)) {
        delete state.zonesByCar[oldId];
        state.selectedCars.delete(oldId);
        if (state.activeCarId === oldId) state.activeCarId = null;
      }
    }

    state.cars = cars;
    state.carsById = new Map(cars.map(c => [c.id, c]));

    // ha activeCarId m√°r nincs kijel√∂lve, dobjuk
    if (state.activeCarId && !state.selectedCars.has(state.activeCarId)) {
      state.activeCarId = null;
    }

    setSubline(`Aut√≥k bet√∂ltve: ${cars.length} ‚Ä¢ Kijel√∂lt: ${state.selectedCars.size}`);
    saveState();

    renderCars();
    renderHotZones();
    renderCarList();
    updateHudButtons();
  }

  async function loadLimoZones() {
    let hz = null;
    try {
      hz = await loadGlobalArrayAny(CFG.LIMO_ZONES_URLS, 'homezones', 12000);
    } catch {
      state.limoZonesLoaded = false;
      return;
    }

    let fc = null;
    if (hz && typeof hz === 'object' && hz.type && (hz.type === 'FeatureCollection' || hz.type === 'Feature')) {
      fc = hz;
    } else if (Array.isArray(hz)) {
      const features = [];
      for (const it of hz) {
        if (!it) continue;
        if (it.cityId && CFG.BUDAPEST_CITY_ID && it.cityId !== CFG.BUDAPEST_CITY_ID) continue;
        const z = it.zone ?? it.geojson ?? it.featureCollection ?? it;
        if (z && z.type === 'FeatureCollection' && Array.isArray(z.features)) {
          for (const f of z.features) features.push(f);
        } else if (z && z.type === 'Feature') {
          features.push(z);
        }
      }
      fc = { type: 'FeatureCollection', features };
    }

    if (!fc || !fc.features || !fc.features.length) {
      state.limoZonesLoaded = false;
      return;
    }

    if (state.limoZones) {
      try { state.zoneLayer.removeLayer(state.limoZones); } catch {}
    }

    state.limoZones = L.geoJSON(fc, {
      style: (feature) => {
        const t = feature?.properties?.type;
        const isAllowed = (t === 'allowed');
        return {
          color: isAllowed ? 'rgba(34,197,94,.85)' : 'rgba(239,68,68,.85)',
          weight: 2,
          fillColor: isAllowed ? 'rgba(34,197,94,.25)' : 'rgba(239,68,68,.28)',
          fillOpacity: isAllowed ? 0.18 : 0.22,
        };
      },
      interactive: false
    });

    state.limoZonesLoaded = true;
    if (state.zonesOn) state.zoneLayer.addLayer(state.limoZones);
  }

  function setZonesOn(on, silent=false) {
    state.zonesOn = !!on;
    $('toggleZones').classList.toggle('on', state.zonesOn);

    if (state.limoZonesLoaded && state.limoZones) {
      if (state.zonesOn) state.zoneLayer.addLayer(state.limoZones);
      else state.zoneLayer.removeLayer(state.limoZones);
    }
    if (!silent) saveState();
  }

  function setBkvOn(on, silent=false) {
    state.bkvOn = !!on;
    const el = $('toggleBkv');
    el.classList.toggle('on', state.bkvOn);

    if (state.bkvOn && !(window.GTFS && window.GTFS.isReady && window.GTFS.isReady())) {
      showStatus('BKV m√≥d', 'GTFS h√°l√≥ nincs el≈ëk√©sz√≠tve (gtfs/graph.json).', 5000);
      state.bkvOn = false;
      el.classList.remove('on');
    }
    if (!silent) saveState();
  }

  // ---------- Car marker icon ----------
  function carIcon(isActive=false) {
    const border = isActive ? 'border:2px solid rgba(255,176,0,.95);' : 'border:1px solid rgba(255,255,255,.18);';
    const ring = isActive ? 'box-shadow:0 0 0 3px rgba(255,176,0,.25), 0 16px 38px rgba(0,0,0,.45);' : 'box-shadow:0 14px 34px rgba(0,0,0,.40);';
    return L.divIcon({
      className: '',
      html: `<div style="
        width:34px;height:34px;border-radius:14px;
        background:rgba(17,24,39,.92);
        ${border}${ring}
        display:flex;align-items:center;justify-content:center;
      ">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="white" opacity=".92" aria-hidden="true">
          <path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.22.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.85 6h10.29l1.04 3H5.81l1.04-3zM19 17H5v-6h14v6zm-12.5-1c.83 0 1.5-.67 1.5-1.5S7.33 13 6.5 13 5 13.67 5 14.5 5.67 16 6.5 16zm11 0c.83 0 1.5-.67 1.5-1.5S18.33 13 17.5 13 16 13.67 16 14.5 16.67 16 17.5 16z"/>
        </svg>
      </div>`,
      iconSize: [34,34],
      iconAnchor: [17,17],
    });
  }

  function shouldShowLabels(visibleCount) {
    const z = state.map.getZoom();
    if (state.activeCarId) return true;
    if (visibleCount <= 15) return true;
    return z >= 16 && visibleCount <= 40;
  }

  function getVisibleCarIds() {
    // csak kijel√∂ltek l√°tszanak
    if (state.selectedCars.size === 0) return [];
    // akt√≠v m√≥dban csak az akt√≠v aut√≥
    if (state.activeCarId && state.selectedCars.has(state.activeCarId)) return [state.activeCarId];
    return Array.from(state.selectedCars);
  }

  function renderCars() {
    state.carsLayer.clearLayers();
    state.labelLayer.clearLayers();
    state.carMarkers.clear();
    state.carLabelMarkers.clear();

    renderMe(); // keep me marker

    const visibleIds = getVisibleCarIds();
    const showLabels = shouldShowLabels(visibleIds.length);

    for (const id of visibleIds) {
      const c = state.carsById.get(id);
      if (!c) continue;

      const isActive = (state.activeCarId === id);
      const m = L.marker([c.lat, c.lng], { icon: carIcon(isActive), keyboard: false });
      m._carId = id;
      m.on('click', () => onCarClick(id));
      state.carMarkers.set(id, m);
      state.carsLayer.addLayer(m);

      if (showLabels) {
        const lab = L.marker([c.lat, c.lng], {
          interactive: false,
          icon: L.divIcon({
            className: '',
            html: `<div class="plate-label">${escapeHtml(c.plate)}</div>`,
            iconSize: [1,1],
            iconAnchor: [-2, 26],
          })
        });
        state.carLabelMarkers.set(id, lab);
        state.labelLayer.addLayer(lab);
      }
    }

    setSubline(`Aut√≥k bet√∂ltve: ${state.cars.length} ‚Ä¢ Kijel√∂lt: ${state.selectedCars.size}`);
  }

  function onCarClick(carId) {
    // ha nincs kijel√∂lve, kijel√∂lj√ºk
    invalidatePlan('Kijel√∂l√©sek/akt√≠v aut√≥ m√≥dosult.');

    state.selectedCars.add(carId);
    state.activeCarId = carId;
    state.moveZone = null;
    closeZoneEditor();

    saveState();
    renderCars();
    renderHotZones();
    renderCarList();
    updateHudButtons();

    const car = state.carsById.get(carId);
    if (car) {
      state.map.panTo([car.lat, car.lng], { animate: true });
      showStatus('Hot zone m√≥d', `${car.plate}: t√©rk√©pre katt = hot zone`, 2600);
    }
  }

  // ---------- Drawer ----------
  function toggleDrawer(show) {
    $('drawer').classList.toggle('show', !!show);
    if (show) renderCarList();
  }

  function renderCarList() {
    const q = ($('carSearch').value || '').trim().toLowerCase();
    const list = $('carList');
    list.innerHTML = '';

    const cars = state.cars
      .filter(c => !q || c.plate.toLowerCase().includes(q) || c.model.toLowerCase().includes(q))
      .sort((a,b) => {
        const as = state.selectedCars.has(a.id) ? 0 : 1;
        const bs = state.selectedCars.has(b.id) ? 0 : 1;
        if (as !== bs) return as - bs;           // kijel√∂ltek fel√ºl
        return a.plate.localeCompare(b.plate);   // ut√°na ABC
      });

    $('drawerSub').textContent = `${cars.length} aut√≥ ‚Ä¢ kijel√∂lt: ${state.selectedCars.size}`;

    for (const c of cars) {
      const zCount = (state.zonesByCar[c.id] || []).length;
      const isChecked = state.selectedCars.has(c.id);
      const isActive = (state.activeCarId === c.id);

      const item = document.createElement('div');
      item.className = 'carItem' + (isActive ? ' active' : '');

      const left = document.createElement('div');
      left.className = 'carLeft';

      const chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.className = 'chk';
      chk.checked = isChecked;

      chk.addEventListener('change', () => {
        invalidatePlan('Kijel√∂l√©sek m√≥dosultak.');

        if (chk.checked) {
          state.selectedCars.add(c.id);
        } else {
          // ha nem akt√≠v (nincs kijel√∂lve), hot zone se legyen
          state.selectedCars.delete(c.id);
          delete state.zonesByCar[c.id];
          if (state.activeCarId === c.id) state.activeCarId = null;
          state.moveZone = null;
          closeZoneEditor();
        }

        saveState();
        renderCars();
        renderHotZones();
        renderCarList();
        updateHudButtons();
      });

      const main = document.createElement('div');
      main.className = 'carMain';
      main.innerHTML = `
        <div class="plate">${escapeHtml(c.plate)}</div>
        <div class="carMeta">${escapeHtml(c.model || '‚Äî')} ‚Ä¢ hot zone: ${zCount}</div>
        ${zCount ? `<div class="tag">üî• hot zone: <b>${zCount}</b></div>` : ``}
      `;

      // katt a sorra -> akt√≠vv√° teszi (hotzone m√≥d)
      main.addEventListener('click', () => onCarClick(c.id));

      left.appendChild(chk);
      left.appendChild(main);

      const btns = document.createElement('div');
      btns.className = 'carBtns';

      const bGo = document.createElement('button');
      bGo.className = 'btn';
      bGo.textContent = 'Odaugr√°s';
      bGo.addEventListener('click', () => {
        state.map.setView([c.lat, c.lng], Math.max(state.map.getZoom(), 16), { animate: true });
      });

      const bActive = document.createElement('button');
      bActive.className = 'btn warn';
      bActive.textContent = 'Hot zone';
      bActive.addEventListener('click', () => onCarClick(c.id));

      btns.appendChild(bGo);
      btns.appendChild(bActive);

      item.appendChild(left);
      item.appendChild(btns);
      list.appendChild(item);
    }
  }

  // ---------- Hot zones ----------
  function renderHotZones() {
    state.hotZoneLayer.clearLayers();

    // akt√≠v m√≥dban csak az akt√≠v aut√≥ z√≥n√°i
    const ids = state.activeCarId ? [state.activeCarId] : Array.from(state.selectedCars);

    for (const carId of ids) {
      if (!state.selectedCars.has(carId)) continue;
      const car = state.carsById.get(carId);
      if (!car) continue;

      const zones = state.zonesByCar[carId] || [];
      zones.forEach((z, idx) => {
        const circle = L.circle([z.lat, z.lng], {
          radius: state.hotRadius,
          color: 'rgba(220,38,38,.80)',
          fillColor: 'rgba(220,38,38,.18)',
          fillOpacity: 0.25,
          weight: 2,
          interactive: true
        });

        circle.on('click', (e) => {
          L.DomEvent.stopPropagation(e);
          openZoneEditor(carId, idx);
        });

        state.hotZoneLayer.addLayer(circle);

        const marker = L.marker([z.lat, z.lng], {
          icon: L.divIcon({
            className: '',
            html: `<div class="target-label"><small>${escapeHtml(car.plate)}</small> #${idx+1}</div>`,
            iconSize: [1,1],
            iconAnchor: [0, 18]
          }),
          interactive: true
        });

        marker.on('click', (e) => {
          L.DomEvent.stopPropagation(e);
          openZoneEditor(carId, idx);
        });

        state.hotZoneLayer.addLayer(marker);
      });
    }
  }

  function openZoneEditor(carId, zoneIndex) {
    // kattint√°skor: az adott aut√≥ legyen akt√≠v, √©s lehessen t√∂r√∂lni/mozgatni
    invalidatePlan('Hot zone szerkeszt√©s.');

    state.selectedCars.add(carId);
    state.activeCarId = carId;
    state.moveZone = null;

    state.editingZone = { carId, zoneIndex };
    const car = state.carsById.get(carId);
    const z = (state.zonesByCar[carId] || [])[zoneIndex];

    $('zeTitle').textContent = `${car ? car.plate : '‚Äî'} ‚Ä¢ Hot zone #${zoneIndex+1}`;
    $('zeSub').textContent = z ? `${z.lat.toFixed(5)}, ${z.lng.toFixed(5)}` : '‚Äî';
    $('zoneEditor').classList.add('show');

    saveState();
    renderCars();
    renderHotZones();
    renderCarList();
    updateHudButtons();
  }

  function closeZoneEditor() {
    $('zoneEditor').classList.remove('show');
    state.editingZone = null;
  }

  // Map click: add zone to active car OR move zone if moveZone active
  function onMapClick(e) {
    if (state.moveZone) {
      const { carId, zoneIndex } = state.moveZone;
      const zs = state.zonesByCar[carId] || [];
      if (zs[zoneIndex]) {
        zs[zoneIndex].lat = e.latlng.lat;
        zs[zoneIndex].lng = e.latlng.lng;
        zs[zoneIndex].movedAt = Date.now();
        state.zonesByCar[carId] = zs;
      }
      state.moveZone = null;
      saveState();
      renderHotZones();
      renderCarList();
      showStatus('√Åthelyezve', `Hot zone #${zoneIndex+1} √°thelyezve.`, 1800);
      return;
    }

    if (!state.activeCarId) return;
    if (!state.selectedCars.has(state.activeCarId)) return;

    invalidatePlan('Hot zone m√≥dosult.');

    if (!state.zonesByCar[state.activeCarId]) state.zonesByCar[state.activeCarId] = [];
    state.zonesByCar[state.activeCarId].push({ lat: e.latlng.lat, lng: e.latlng.lng, createdAt: Date.now() });

    saveState();
    renderHotZones();
    renderCarList();

    const car = state.carsById.get(state.activeCarId);
    showStatus('Hot zone hozz√°adva', `${car ? car.plate : '‚Äî'} ‚Ä¢ #${state.zonesByCar[state.activeCarId].length}`, 1600);
  }

  // ---------- Plan sheet behaviors ----------
  function minimizeSheet() {
    state.sheetMinimized = true;
    $('sheet').classList.remove('show');
    updateHudButtons();
    showStatus('Csukva', 'A terv a t√©rk√©pen l√°tszik, a panel el lett rejtve.', 1600);
  }
  function showSheet() {
    state.sheetMinimized = false;
    $('sheet').classList.add('show');
    updateHudButtons();
  }

  function updateHudButtons() {
    $('btnExitActive').style.display = state.activeCarId ? 'inline-flex' : 'none';
    $('btnShowPlan').style.display = (state.planActive && state.sheetMinimized) ? 'inline-flex' : 'none';
  }

  // ---------- Planning ----------
  function getCandidateCars() {
    // csak kijel√∂lt aut√≥k, amelyeknek van hotzone-ja
    const out = [];
    for (const id of state.selectedCars) {
      const c = state.carsById.get(id);
      if (!c) continue;
      const zs = state.zonesByCar[id] || [];
      if (zs.length) out.push(c);
    }
    return out;
  }

  async function planNow() {
    const candidates = getCandidateCars();
    if (!candidates.length) {
      showStatus('Tervez√©s', 'Nincs kijel√∂lt aut√≥ hot zone-nal.', 3000);
      return;
    }
    if (!state.me) {
      showStatus('Tervez√©s', 'GPS poz√≠ci√≥ m√©g nincs. Enged√©lyezd a helyzetet.', 4000);
      return;
    }

    closeZoneEditor();
    state.moveZone = null;

    showStatus('Sz√°mol√°s‚Ä¶', '√ötvonaltervez√©s folyamatban (OSRM)‚Ä¶', 0);
    $('sheet').classList.add('show');
    state.sheetMinimized = false;
    $('sheetTitle').textContent = 'Sz√°mol√°s‚Ä¶';
    $('sheetSub').textContent = 'K√©rlek v√°rj‚Ä¶';
    $('steps').innerHTML = '';

    const start = { lat: state.me.lat, lng: state.me.lng, name: '√ân' };

    try {
      const startCar = await pickNearestCar(start, candidates);
      const plan = await solvePlan(start, candidates, startCar);

      state.planActive = true;
      state.plan = plan;

      showPlanView(plan);
      saveState();
      updateHudButtons();
    } catch (e) {
      showStatus('Hiba', (e && e.message) ? e.message : String(e), 5000);
      clearPlan({ silent: true });
    }
  }

  async function pickNearestCar(start, cars) {
    try {
      const coords = [[start.lng, start.lat], ...cars.map(c => [c.lng, c.lat])];
      const res = await osrmTable('foot', coords, [0], cars.map((_,i)=>i+1));
      let best = null;
      for (let i=0;i<cars.length;i++){
        const d = res.durations[0][i];
        if (d == null) continue;
        if (!best || d < best.d) best = { d, car: cars[i] };
      }
      if (best) return best.car;
    } catch {}
    let best = cars[0], bestM = Infinity;
    for (const c of cars) {
      const m = haversineM(start.lat, start.lng, c.lat, c.lng);
      if (m < bestM) { bestM = m; best = c; }
    }
    return best;
  }

  async function solvePlan(start, cars, startCar) {
    const carList = [startCar, ...cars.filter(c => c.id !== startCar.id)];
    const n = carList.length;

    const zonesNodes = []; // {carIdx, zoneIdx, lat,lng, id}
    for (let i=0;i<n;i++) {
      const c = carList[i];
      const zs = (state.zonesByCar[c.id] || []).map((z, idx) => ({
        carIdx: i,
        zoneIdx: idx,
        lat: z.lat, lng: z.lng,
        id: `${c.id}#${idx+1}`,
      }));
      zonesNodes.push(...zs);
    }
    const zonesForCar = (ci) => zonesNodes.filter(z => z.carIdx === ci);

    const coords = [
      [start.lng, start.lat],
      ...zonesNodes.map(z => [z.lng, z.lat]),
      ...carList.map(c => [c.lng, c.lat]),
    ];
    const coordZoneOffset = 1;
    const coordCarOffset = 1 + zonesNodes.length;

    let footTable = null;
    try {
      const origins = [0, ...zonesNodes.map((_,i)=>coordZoneOffset+i)];
      const dests = carList.map((_,i)=>coordCarOffset+i);
      footTable = await osrmTable('foot', coords, origins, dests);
    } catch { footTable = null; }

    const driveCost = new Map();
    for (let ci=0; ci<n; ci++) {
      const zs = zonesForCar(ci);
      if (!zs.length) continue;
      try {
        const c = carList[ci];
        const cc = [[c.lng, c.lat], ...zs.map(z => [z.lng, z.lat])];
        const t = await osrmTable('car', cc, [0], zs.map((_,i)=>i+1));
        for (let zi=0; zi<zs.length; zi++) {
          const d = t.durations[0][zi];
          const dist = t.distances ? t.distances[0][zi] : null;
          driveCost.set(`${ci}|${zs[zi].id}`, { duration: d, distance: dist });
        }
      } catch {
        const c = carList[ci];
        for (const z of zs) {
          const m = haversineM(c.lat, c.lng, z.lat, z.lng);
          driveCost.set(`${ci}|${z.id}`, { duration: (m/1000)/(20/60/60), distance: m });
        }
      }
    }

    function coordToLatLng(coordIdx) {
      if (coordIdx === 0) return { lat: start.lat, lng: start.lng };
      const z = zonesNodes[coordIdx - 1];
      return { lat: z.lat, lng: z.lng };
    }

    function footDuration(fromCoordIdx, carIdx) {
      if (footTable) {
        const rowIndex = fromCoordIdx; // origins = [0,1,2,...]
        const d = footTable.durations[rowIndex]?.[carIdx];
        const dist = footTable.distances ? footTable.distances[rowIndex]?.[carIdx] : null;
        if (d != null) return { duration: d, distance: dist };
      }
      const from = coordToLatLng(fromCoordIdx);
      const m = haversineM(from.lat, from.lng, carList[carIdx].lat, carList[carIdx].lng);
      return { duration: (m/1000)/(5/60/60), distance: m };
    }

    // Exact DP up to 8 cars else greedy
    const EXACT_LIMIT = 8;
    if (n > EXACT_LIMIT) {
      const steps = [];
      const done = new Set();
      let lastCoordIdx = 0;

      // first car forced = 0
      done.add(0);
      {
        const zs = zonesForCar(0);
        let best = null;
        for (const z of zs) {
          const w = footDuration(0,0);
          const d = driveCost.get(`0|${z.id}`);
          if (!d) continue;
          const cost = w.duration + d.duration;
          if (!best || cost < best.cost) best = { z, w, d, cost };
        }
        const coordIdx = 1 + zonesNodes.findIndex(x => x.id === best.z.id);
        steps.push({ carIdx:0, zoneId: best.z.id, fromCoordIdx: 0, walk: best.w, drive: best.d });
        lastCoordIdx = coordIdx;
      }

      while (done.size < n) {
        let best = null;
        for (let ci=0; ci<n; ci++) {
          if (done.has(ci)) continue;
          const zs = zonesForCar(ci);
          for (const z of zs) {
            const w = footDuration(lastCoordIdx, ci);
            const d = driveCost.get(`${ci}|${z.id}`);
            if (!d) continue;
            const cost = w.duration + d.duration;
            if (!best || cost < best.cost) best = { ci, z, w, d, cost };
          }
        }
        if (!best) break;
        done.add(best.ci);
        const coordIdx = 1 + zonesNodes.findIndex(x => x.id === best.z.id);
        steps.push({ carIdx: best.ci, zoneId: best.z.id, fromCoordIdx: lastCoordIdx, walk: best.w, drive: best.d });
        lastCoordIdx = coordIdx;
      }

      return buildPlanDetails(start, carList, zonesNodes, steps);
    }

    const zoneCoordIndexById = new Map();
    zonesNodes.forEach((z, i) => zoneCoordIndexById.set(z.id, 1 + i));

    const allMask = (1 << n) - 1;
    const memo = new Map();

    async function solve(mask, lastCoordIdx) {
      const key = `${mask}|${lastCoordIdx}`;
      if (memo.has(key)) return memo.get(key);

      if (mask === allMask) {
        const res = { cost: 0, path: [] };
        memo.set(key, res);
        return res;
      }

      let best = { cost: Infinity, path: [] };

      for (let ci=0; ci<n; ci++) {
        if (mask & (1<<ci)) continue;

        const zs = zonesForCar(ci);
        for (const z of zs) {
          const w = footDuration(lastCoordIdx, ci);
          const d = driveCost.get(`${ci}|${z.id}`);
          if (!d || d.duration == null) continue;

          const stepCost = w.duration + d.duration;
          const nextCoordIdx = zoneCoordIndexById.get(z.id);
          const next = await solve(mask | (1<<ci), nextCoordIdx);
          const total = stepCost + next.cost;

          if (total < best.cost) {
            best = {
              cost: total,
              path: [{
                carIdx: ci,
                zoneId: z.id,
                fromCoordIdx: lastCoordIdx,
                walk: w,
                drive: d
              }, ...next.path]
            };
          }
        }
      }

      memo.set(key, best);
      return best;
    }

    // first car fixed idx0
    const zs0 = zonesForCar(0);
    let bestOverall = { cost: Infinity, steps: [] };

    for (const z0 of zs0) {
      const w0 = footDuration(0, 0);
      const d0 = driveCost.get(`0|${z0.id}`);
      if (!d0 || d0.duration == null) continue;

      const coordIdx0 = zoneCoordIndexById.get(z0.id);
      const next = await solve(1<<0, coordIdx0);
      const total = w0.duration + d0.duration + next.cost;

      if (total < bestOverall.cost) {
        bestOverall = {
          cost: total,
          steps: [{
            carIdx: 0,
            zoneId: z0.id,
            fromCoordIdx: 0,
            walk: w0,
            drive: d0
          }, ...next.path]
        };
      }
    }

    return buildPlanDetails(start, carList, zonesNodes, bestOverall.steps);
  }

  function findZoneById(zonesNodes, id) {
    return zonesNodes.find(z => z.id === id);
  }

  async function buildPlanDetails(start, carList, zonesNodes, steps) {
    const planSteps = [];
    let totalWalk = 0, totalDrive = 0;

    for (let i=0; i<steps.length; i++) {
      const s = steps[i];
      const car = carList[s.carIdx];
      const zone = findZoneById(zonesNodes, s.zoneId);

      const from = (s.fromCoordIdx === 0)
        ? { lat: start.lat, lng: start.lng }
        : { lat: zonesNodes[s.fromCoordIdx - 1].lat, lng: zonesNodes[s.fromCoordIdx - 1].lng };

      const toCar = { lat: car.lat, lng: car.lng };
      const toZone = { lat: zone.lat, lng: zone.lng };

      const walkLeg = await routeLeg('walk', from, toCar);
      const driveLeg = await routeLeg('drive', toCar, toZone);

      totalWalk += walkLeg.duration;
      totalDrive += driveLeg.duration;

      planSteps.push({
        idx: i + 1,
        carId: car.id,
        carPlate: car.plate,
        carModel: car.model,
        zoneNo: Number(zone.id.split('#')[1] || 1),
        walk: walkLeg,
        drive: driveLeg,
      });
    }

    return {
      carsUsed: Array.from(new Set(planSteps.map(p => p.carId))),
      steps: planSteps,
      summary: {
        total: totalWalk + totalDrive,
        walk: totalWalk,
        drive: totalDrive,
      }
    };
  }

  async function routeLeg(kind, from, to) {
    if (kind === 'walk' && state.bkvOn && window.GTFS && window.GTFS.isReady && window.GTFS.isReady()) {
      try {
        const alt = await window.GTFS.plan(from, to, { maxWalkToStopM: CFG.TRANSIT_MAX_WALK_TO_STOP_M });
        const m = haversineM(from.lat, from.lng, to.lat, to.lng);
        const approxWalk = (m/1000)/(5/60/60);

        if (alt && alt.totalDuration && alt.totalDuration < approxWalk * 0.90) {
          // geometry: OSRM "car" multi-route a via pontokra, hogy √∫tra illeszkedjen
          let geom = alt.viaPoints;
          try {
            geom = await osrmRouteMulti('car', alt.viaPoints);
          } catch {
            // marad a viaPoints (t√∂r√∂tt vonal), ha az OSRM multi-route nem megy
          }

          return {
            mode: 'bkv',
            duration: alt.totalDuration,
            distance: null,
            geometry: geom,
            ascent: null,
            descent: null,
            meta: alt.meta
          };
        }
      } catch {}
    }

    const profile = (kind === 'walk') ? 'foot' : 'car';
    const res = await osrmRoute(profile, from, to);

    let ascent = null, descent = null;
    if (kind === 'walk') {
      const elev = await getElevationStats(res.geometry);
      ascent = elev ? elev.ascent : null;
      descent = elev ? elev.descent : null;
    }

    return {
      mode: profile,
      duration: res.duration,
      distance: res.distance,
      geometry: res.geometry,
      ascent, descent,
      meta: null
    };
  }

  // ---------- OSRM helpers ----------
  function osrmKey(profile, from, to) {
    return `${profile}|${from.lat.toFixed(6)},${from.lng.toFixed(6)}|${to.lat.toFixed(6)},${to.lng.toFixed(6)}`;
  }

  async function osrmRoute(profile, from, to) {
    const key = osrmKey(profile, from, to);
    if (state.osrmCache.has(key)) return state.osrmCache.get(key);

    const baseUrls = profile === 'foot' ? CFG.OSRM_FOOT : CFG.OSRM_CAR;
    let lastErr = null;

    for (const base of baseUrls) {
      try {
        const url = `${base}/route/v1/${profile}/${from.lng},${from.lat};${to.lng},${to.lat}?overview=full&geometries=geojson&alternatives=false&steps=false`;
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const j = await r.json();
        if (!j.routes || !j.routes[0]) throw new Error('no routes');
        const route = j.routes[0];
        const out = {
          duration: route.duration,
          distance: route.distance,
          geometry: route.geometry.coordinates.map(c => ({ lat: c[1], lng: c[0] })),
        };
        state.osrmCache.set(key, out);
        return out;
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error('OSRM route failed');
  }

  async function osrmRouteMulti(profile, points) {
    // points: [{lat,lng}, ...] (min 2)
    if (!points || points.length < 2) throw new Error('multi: too few points');
    const baseUrls = profile === 'foot' ? CFG.OSRM_FOOT : CFG.OSRM_CAR;

    // limit: OSRM is fine with dozens, de ne legyen t√∫l sok
    const maxPts = 22;
    let pts = points;
    if (points.length > maxPts) {
      const step = Math.ceil(points.length / maxPts);
      const reduced = [];
      for (let i=0;i<points.length;i+=step) reduced.push(points[i]);
      if (reduced[reduced.length-1] !== points[points.length-1]) reduced.push(points[points.length-1]);
      pts = reduced;
    }

    const coordsStr = pts.map(p => `${p.lng},${p.lat}`).join(';');

    let lastErr = null;
    for (const base of baseUrls) {
      try {
        const url = `${base}/route/v1/${profile}/${coordsStr}?overview=full&geometries=geojson&steps=false&alternatives=false`;
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const j = await r.json();
        if (!j.routes || !j.routes[0]) throw new Error('no routes');
        const route = j.routes[0];
        return route.geometry.coordinates.map(c => ({ lat: c[1], lng: c[0] }));
      } catch (e) { lastErr = e; }
    }
    throw lastErr || new Error('OSRM multi-route failed');
  }

  async function osrmTable(profile, coords, origins, destinations) {
    const baseUrls = profile === 'foot' ? CFG.OSRM_FOOT : CFG.OSRM_CAR;
    const coordsStr = coords.map(c => `${c[0]},${c[1]}`).join(';');
    const originsStr = origins.join(';');
    const destStr = destinations.join(';');

    let lastErr = null;
    for (const base of baseUrls) {
      try {
        const url = `${base}/table/v1/${profile}/${coordsStr}?sources=${originsStr}&destinations=${destStr}&annotations=duration,distance`;
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const j = await r.json();
        if (!j.durations) throw new Error('no durations');
        return j;
      } catch (e) { lastErr = e; }
    }
    throw lastErr || new Error('OSRM table failed');
  }

  // ---------- Elevation (best-effort) ----------
  async function getElevationStats(latlngs) {
    if (!latlngs || latlngs.length < 2) return null;

    const key = latlngs.length + '|' +
      latlngs[0].lat.toFixed(5)+','+latlngs[0].lng.toFixed(5)+'|' +
      latlngs[Math.floor(latlngs.length/2)].lat.toFixed(5)+','+latlngs[Math.floor(latlngs.length/2)].lng.toFixed(5)+'|' +
      latlngs[latlngs.length-1].lat.toFixed(5)+','+latlngs[latlngs.length-1].lng.toFixed(5);

    if (state.elevationCache.has(key)) return state.elevationCache.get(key);

    const N = Math.min(50, latlngs.length);
    const pts = [];
    for (let i=0; i<N; i++) {
      const idx = Math.floor(i * (latlngs.length-1) / (N-1));
      pts.push(latlngs[idx]);
    }

    const loc = pts.map(p => `${p.lat},${p.lng}`).join('|');
    const url = `https://api.opentopodata.org/v1/aster30m?locations=${encodeURIComponent(loc)}`;

    try {
      const r = await fetch(url, { cache: 'force-cache' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const j = await r.json();
      if (!j || !j.results) throw new Error('bad json');
      const elevs = j.results.map(x => x.elevation).filter(x => typeof x === 'number');
      if (elevs.length < 2) return null;

      let ascent = 0, descent = 0;
      for (let i=1;i<elevs.length;i++){
        const d = elevs[i]-elevs[i-1];
        if (d > 0) ascent += d;
        else descent += -d;
      }
      const out = { ascent: Math.round(ascent), descent: Math.round(descent) };
      state.elevationCache.set(key, out);
      return out;
    } catch {
      return null;
    }
  }

  // ---------- Show plan ----------
  function clearPlan({ silent=false } = {}) {
    state.planActive = false;
    state.plan = null;
    state.routeLayer.clearLayers();
    state.sheetMinimized = false;
    $('sheet').classList.remove('show');
    updateHudButtons();
    if (!silent) showStatus('Bez√°rva', 'A terv t√∂r√∂lve.', 1400);
  }

  function showPlanView(plan) {
    state.routeLayer.clearLayers();

    // hide sheet minimized? keep as is
    $('sheet').classList.add('show');
    state.sheetMinimized = false;

    $('sheetTitle').textContent = 'K√©sz';
    $('sheetSub').textContent = `√ñssz-id≈ë: ${fmtMin(plan.summary.total)} (üö∂ ${fmtMin(plan.summary.walk)} + üöó ${fmtMin(plan.summary.drive)})`;

    const allLatLngs = [];
    for (const step of plan.steps) {
      // WALK/BKV
      const w = step.walk;

      // sz√≠nek + szaggat√°sok
      let wColor = 'rgba(250,204,21,.95)';     // gyalog: s√°rga
      let wDash = '10 14';
      if (w.mode === 'bkv') {
        wColor = 'rgba(29,78,216,.95)';        // bkv: s√∂t√©tk√©k
        wDash = '12 16';
      }

      const wLine = L.polyline(w.geometry.map(p => [p.lat, p.lng]), {
        color: wColor,
        weight: 7,
        opacity: 0.95,
        dashArray: wDash,
        lineCap: 'round',
        lineJoin: 'round'
      });
      state.routeLayer.addLayer(wLine);
      allLatLngs.push(...w.geometry.map(p => [p.lat, p.lng]));

      // DRIVE (aut√≥)
      const d = step.drive;
      const dLine = L.polyline(d.geometry.map(p => [p.lat, p.lng]), {
        color: 'rgba(239,68,68,.95)',           // piros
        weight: 7,
        opacity: 0.95,
        lineCap: 'round',
        lineJoin: 'round'
      });
      state.routeLayer.addLayer(dLine);
      allLatLngs.push(...d.geometry.map(p => [p.lat, p.lng]));
    }

    if (allLatLngs.length) {
      const b = L.latLngBounds(allLatLngs);
      state.map.fitBounds(b.pad(0.15), { animate: true });
    }

    const stepsEl = $('steps');
    stepsEl.innerHTML = '';

    plan.steps.forEach((s, i) => {
      const el = document.createElement('div');
      el.className = 'step';

      const walk = s.walk;
      const drive = s.drive;

      // BKV meta: vonalak + felsz√°ll√≥/lesz√°ll√≥
      let bkvExtra = '';
      if (walk.mode === 'bkv') {
        const routes = (walk.meta && Array.isArray(walk.meta.routes) && walk.meta.routes.length)
          ? walk.meta.routes.join(', ')
          : '‚Äî';
        const board = walk.meta?.boardStop ?? '‚Äî';
        const alight = walk.meta?.alightStop ?? '‚Äî';
        bkvExtra = `<br>Vonal: <b>${escapeHtml(routes)}</b> ‚Ä¢ Felsz√°ll√°s: <b>${escapeHtml(board)}</b> ‚Ä¢ Lesz√°ll√°s: <b>${escapeHtml(alight)}</b>`;
      }

      const asc = (walk.ascent != null && walk.descent != null) ? ` ‚Ä¢ ${walk.ascent} m ‚Üó ${walk.descent} m ‚Üò` : '';
      const walkLabel = (walk.mode === 'bkv') ? 'BKV' : 'Gyalog';
      const walkMeta = `${walkLabel}: ${fmtMin(walk.duration)} ‚Ä¢ ${fmtKm(walk.distance)}${asc}${bkvExtra}`;
      const driveMeta = `Aut√≥: ${fmtMin(drive.duration)} ‚Ä¢ ${fmtKm(drive.distance)}`;

      el.innerHTML = `
        <div class="badge">${i+1}</div>
        <div style="min-width:0;">
          <div class="stepTitle">${escapeHtml(s.carPlate)} ‚Üí Hot zone #${s.zoneNo}</div>
          <div class="stepMeta">${walkMeta}<br>${driveMeta}</div>
        </div>
      `;
      stepsEl.appendChild(el);
    });

    showStatus('K√©sz', `Sorrend: ${plan.steps.map(s => s.carPlate).join(' ‚Üí ')}`, 2800);
  }

  // ---------- Boot ----------
  initMap();

})();
  </script>
</body>
</html>
